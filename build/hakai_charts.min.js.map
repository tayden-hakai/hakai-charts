{"version":3,"sources":["node_modules/browser-pack/_prelude.js","hakai_charts.min.js","index.js","node_modules/simple-statistics/index.js","node_modules/simple-statistics/src/bayesian_classifier.js","node_modules/simple-statistics/src/bernoulli_distribution.js","node_modules/simple-statistics/src/binomial_distribution.js","node_modules/simple-statistics/src/chi_squared_distribution_table.js","node_modules/simple-statistics/src/chi_squared_goodness_of_fit.js","node_modules/simple-statistics/src/chunk.js","node_modules/simple-statistics/src/ckmeans.js","node_modules/simple-statistics/src/cumulative_std_normal_probability.js","node_modules/simple-statistics/src/epsilon.js","node_modules/simple-statistics/src/error_function.js","node_modules/simple-statistics/src/factorial.js","node_modules/simple-statistics/src/geometric_mean.js","node_modules/simple-statistics/src/harmonic_mean.js","node_modules/simple-statistics/src/interquartile_range.js","node_modules/simple-statistics/src/inverse_error_function.js","node_modules/simple-statistics/src/linear_regression.js","node_modules/simple-statistics/src/linear_regression_line.js","node_modules/simple-statistics/src/mad.js","node_modules/simple-statistics/src/max.js","node_modules/simple-statistics/src/mean.js","node_modules/simple-statistics/src/median.js","node_modules/simple-statistics/src/min.js","node_modules/simple-statistics/src/mixin.js","node_modules/simple-statistics/src/mode.js","node_modules/simple-statistics/src/numeric_sort.js","node_modules/simple-statistics/src/perceptron.js","node_modules/simple-statistics/src/poisson_distribution.js","node_modules/simple-statistics/src/probit.js","node_modules/simple-statistics/src/quantile.js","node_modules/simple-statistics/src/quantile_sorted.js","node_modules/simple-statistics/src/r_squared.js","node_modules/simple-statistics/src/root_mean_square.js","node_modules/simple-statistics/src/sample.js","node_modules/simple-statistics/src/sample_correlation.js","node_modules/simple-statistics/src/sample_covariance.js","node_modules/simple-statistics/src/sample_skewness.js","node_modules/simple-statistics/src/sample_standard_deviation.js","node_modules/simple-statistics/src/sample_variance.js","node_modules/simple-statistics/src/shuffle.js","node_modules/simple-statistics/src/shuffle_in_place.js","node_modules/simple-statistics/src/sorted_unique_count.js","node_modules/simple-statistics/src/standard_deviation.js","node_modules/simple-statistics/src/standard_normal_table.js","node_modules/simple-statistics/src/sum.js","node_modules/simple-statistics/src/sum_nth_power_deviations.js","node_modules/simple-statistics/src/t_test.js","node_modules/simple-statistics/src/t_test_two_sample.js","node_modules/simple-statistics/src/variance.js","node_modules/simple-statistics/src/z_score.js","src/js/parallel_coordinates.js","src/js/scatterplot.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","parallelCoordinates","scatterplot","./src/js/parallel_coordinates","./src/js/scatterplot",2,"ss","linearRegression","linearRegressionLine","standardDeviation","rSquared","mode","min","max","sum","quantile","quantileSorted","iqr","interquartileRange","medianAbsoluteDeviation","mad","chunk","shuffle","shuffleInPlace","sample","ckmeans","sortedUniqueCount","sumNthPowerDeviations","sampleCovariance","sampleCorrelation","sampleVariance","sampleStandardDeviation","sampleSkewness","geometricMean","harmonicMean","mean","average","median","rootMeanSquare","rms","variance","tTest","tTestTwoSample","bayesian","perceptron","epsilon","factorial","bernoulliDistribution","binomialDistribution","poissonDistribution","chiSquaredGoodnessOfFit","zScore","cumulativeStdNormalProbability","standardNormalTable","errorFunction","erf","inverseErrorFunction","probit","mixin","./src/bayesian_classifier","./src/bernoulli_distribution","./src/binomial_distribution","./src/chi_squared_goodness_of_fit","./src/chunk","./src/ckmeans","./src/cumulative_std_normal_probability","./src/epsilon","./src/error_function","./src/factorial","./src/geometric_mean","./src/harmonic_mean","./src/interquartile_range","./src/inverse_error_function","./src/linear_regression","./src/linear_regression_line","./src/mad","./src/max","./src/mean","./src/median","./src/min","./src/mixin","./src/mode","./src/perceptron","./src/poisson_distribution","./src/probit","./src/quantile","./src/quantile_sorted","./src/r_squared","./src/root_mean_square","./src/sample","./src/sample_correlation","./src/sample_covariance","./src/sample_skewness","./src/sample_standard_deviation","./src/sample_variance","./src/shuffle","./src/shuffle_in_place","./src/sorted_unique_count","./src/standard_deviation","./src/standard_normal_table","./src/sum","./src/sum_nth_power_deviations","./src/t_test","./src/t_test_two_sample","./src/variance","./src/z_score",3,"BayesianClassifier","this","totalCount","data","prototype","train","item","category","k","v","undefined","score","odds","oddsSums","combination",4,"p","./binomial_distribution",5,"trials","probability","x","cumulativeProbability","cells","Math","pow","./epsilon","./factorial",6,"chiSquaredDistributionTable",0.995,0.99,0.975,0.95,0.9,0.5,0.1,0.05,0.025,0.01,0.005,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,40,50,60,70,80,90,100,"distributionType","significance","degreesOfFreedom","inputMean","chiSquared","c","hypothesizedDistribution","observedFrequencies","expectedFrequencies","pop","./chi_squared_distribution_table","./mean","chunkSize","output","start","push","slice","makeMatrix","columns","rows","matrix","column","j","nClusters","sorted","numericSort","uniqueCount","backtrackMatrix","cluster","firstClusterMean","sortedIdx","squaredDifference","newSum","sumSquaredDistances","meanXJ","clusters","clusterRight","clusterLeft","./numeric_sort","./sorted_unique_count","z","absZ","abs","index","round","toFixed","./standard_normal_table","tau","exp","accumulator","value","reciprocalSum","./quantile","PI","inv","sqrt","log","m","b","dataLength","point","y","sumX","sumY","sumXX","sumXY","mb","medianValue","medianAbsoluteDeviations","./median","./sum","array","wrap","method","args","Array","apply","arguments","unshift","support","Object","defineProperty","defineProperties","extending","arrayMethods","configurable","enumerable","writable","last","maxSeen","seenThis","sort","PerceptronModel","weights","bias","predict","features","label","prediction","gradient","lambda","E","./inverse_error_function",31,"results","./quantile_sorted",32,"idx","ceil",33,"func","sumOfSquares","err",34,35,"randomSource","shuffled","./shuffle",36,"cov","xstd","ystd","./sample_covariance","./sample_standard_deviation",37,"xmean","ymean","besselsCorrection",38,"cubedS","sumCubedDeviations","./sum_nth_power_deviations",39,"./sample_variance","sumSquaredDeviationsValue",41,"./shuffle_in_place",42,"random","temporary","floor",43,"input","lastSeenValue","uniqueValueCount",44,"./variance",45,"cumulativeDistribution","tmp","SQRT_2PI",46,47,"meanValue",48,"sampleMean","sd","rootN","./standard_deviation",49,"sampleX","sampleY","difference","meanX","meanY","weightedVariance",51,52,"parent","position","d","_dragging","_x","path","_line","_dimensions","map","_y","dataToLines","result","forEach","dim","line","name","col","d3","sigma","deviation","changeColor","dimension","_svg","selectAll","style","classed","filter","_lineData","parseFloat","select","_color","transition","g","duration","brushstart","event","sourceEvent","stopPropagation","brush","actives","empty","extents","extent","_foreground","every","_chart","append","attr","_width","_margin","left","right","_height","top","bottom","_data","scale","linear","domain","range","ordinal","rangePoints","_background","enter","behavior","drag","origin","on","delay","each","_axis","text","svg","axis","orient","interpolate","interpolateLab","render","redraw","remove","width","val","height","margin",53,"log10","getY","regLine","_xLog","_yLog","calculateStats","ssData","xD","_xAccessor","yD","_yAccessor","correlation","covariance","reg","cleanData","isNaN","_xAxis","tickSize","_yAxis","_xLabel","_yLabel","stats","_regLine","_rSquared","_correlation","_covariance","marks","_radius","_colorAccessor","_keyAccessor","category10","key","exit","xAccessor","yAccessor","xLabel","yLabel","xLog","yLog","color","colorAccessor","keyAccessor","radius","simple-statistics"],"mappings":"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","file":"hakai_charts.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  parallelCoordinates: require('./src/js/parallel_coordinates'),\n  scatterplot: require('./src/js/scatterplot')\n};\n\n},{\"./src/js/parallel_coordinates\":52,\"./src/js/scatterplot\":53}],2:[function(require,module,exports){\n'use strict';\n\n// # simple-statistics\n//\n// A simple, literate statistics system.\n\nvar ss = module.exports = {};\n\n// Linear Regression\nss.linearRegression = require('./src/linear_regression');\nss.linearRegressionLine = require('./src/linear_regression_line');\nss.standardDeviation = require('./src/standard_deviation');\nss.rSquared = require('./src/r_squared');\nss.mode = require('./src/mode');\nss.min = require('./src/min');\nss.max = require('./src/max');\nss.sum = require('./src/sum');\nss.quantile = require('./src/quantile');\nss.quantileSorted = require('./src/quantile_sorted');\nss.iqr = ss.interquartileRange = require('./src/interquartile_range');\nss.medianAbsoluteDeviation = ss.mad = require('./src/mad');\nss.chunk = require('./src/chunk');\nss.shuffle = require('./src/shuffle');\nss.shuffleInPlace = require('./src/shuffle_in_place');\nss.sample = require('./src/sample');\nss.ckmeans = require('./src/ckmeans');\nss.sortedUniqueCount = require('./src/sorted_unique_count');\nss.sumNthPowerDeviations = require('./src/sum_nth_power_deviations');\n\n// sample statistics\nss.sampleCovariance = require('./src/sample_covariance');\nss.sampleCorrelation = require('./src/sample_correlation');\nss.sampleVariance = require('./src/sample_variance');\nss.sampleStandardDeviation = require('./src/sample_standard_deviation');\nss.sampleSkewness = require('./src/sample_skewness');\n\n// measures of centrality\nss.geometricMean = require('./src/geometric_mean');\nss.harmonicMean = require('./src/harmonic_mean');\nss.mean = ss.average = require('./src/mean');\nss.median = require('./src/median');\n\nss.rootMeanSquare = ss.rms = require('./src/root_mean_square');\nss.variance = require('./src/variance');\nss.tTest = require('./src/t_test');\nss.tTestTwoSample = require('./src/t_test_two_sample');\n// ss.jenks = require('./src/jenks');\n\n// Classifiers\nss.bayesian = require('./src/bayesian_classifier');\nss.perceptron = require('./src/perceptron');\n\n// Distribution-related methods\nss.epsilon = require('./src/epsilon'); // We make ε available to the test suite.\nss.factorial = require('./src/factorial');\nss.bernoulliDistribution = require('./src/bernoulli_distribution');\nss.binomialDistribution = require('./src/binomial_distribution');\nss.poissonDistribution = require('./src/poisson_distribution');\nss.chiSquaredGoodnessOfFit = require('./src/chi_squared_goodness_of_fit');\n\n// Normal distribution\nss.zScore = require('./src/z_score');\nss.cumulativeStdNormalProbability = require('./src/cumulative_std_normal_probability');\nss.standardNormalTable = require('./src/standard_normal_table');\nss.errorFunction = ss.erf = require('./src/error_function');\nss.inverseErrorFunction = require('./src/inverse_error_function');\nss.probit = require('./src/probit');\nss.mixin = require('./src/mixin');\n\n},{\"./src/bayesian_classifier\":3,\"./src/bernoulli_distribution\":4,\"./src/binomial_distribution\":5,\"./src/chi_squared_goodness_of_fit\":7,\"./src/chunk\":8,\"./src/ckmeans\":9,\"./src/cumulative_std_normal_probability\":10,\"./src/epsilon\":11,\"./src/error_function\":12,\"./src/factorial\":13,\"./src/geometric_mean\":14,\"./src/harmonic_mean\":15,\"./src/interquartile_range\":16,\"./src/inverse_error_function\":17,\"./src/linear_regression\":18,\"./src/linear_regression_line\":19,\"./src/mad\":20,\"./src/max\":21,\"./src/mean\":22,\"./src/median\":23,\"./src/min\":24,\"./src/mixin\":25,\"./src/mode\":26,\"./src/perceptron\":28,\"./src/poisson_distribution\":29,\"./src/probit\":30,\"./src/quantile\":31,\"./src/quantile_sorted\":32,\"./src/r_squared\":33,\"./src/root_mean_square\":34,\"./src/sample\":35,\"./src/sample_correlation\":36,\"./src/sample_covariance\":37,\"./src/sample_skewness\":38,\"./src/sample_standard_deviation\":39,\"./src/sample_variance\":40,\"./src/shuffle\":41,\"./src/shuffle_in_place\":42,\"./src/sorted_unique_count\":43,\"./src/standard_deviation\":44,\"./src/standard_normal_table\":45,\"./src/sum\":46,\"./src/sum_nth_power_deviations\":47,\"./src/t_test\":48,\"./src/t_test_two_sample\":49,\"./src/variance\":50,\"./src/z_score\":51}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nfunction BayesianClassifier() {\n    // The number of items that are currently\n    // classified in the model\n    this.totalCount = 0;\n    // Every item classified in the model\n    this.data = {};\n}\n\n/**\n * Train the classifier with a new item, which has a single\n * dimension of Javascript literal keys and values.\n *\n * @param {Object} item an object with singly-deep properties\n * @param {string} category the category this item belongs to\n * @return {undefined} adds the item to the classifier\n */\nBayesianClassifier.prototype.train = function(item, category) {\n    // If the data object doesn't have any values\n    // for this category, create a new object for it.\n    if (!this.data[category]) {\n        this.data[category] = {};\n    }\n\n    // Iterate through each key in the item.\n    for (var k in item) {\n        var v = item[k];\n        // Initialize the nested object `data[category][k][item[k]]`\n        // with an object of keys that equal 0.\n        if (this.data[category][k] === undefined) {\n            this.data[category][k] = {};\n        }\n        if (this.data[category][k][v] === undefined) {\n            this.data[category][k][v] = 0;\n        }\n\n        // And increment the key for this key/value combination.\n        this.data[category][k][item[k]]++;\n    }\n\n    // Increment the number of items classified\n    this.totalCount++;\n};\n\n/**\n * Generate a score of how well this item matches all\n * possible categories based on its attributes\n *\n * @param {Object} item an item in the same format as with train\n * @returns {Object} of probabilities that this item belongs to a\n * given category.\n */\nBayesianClassifier.prototype.score = function(item) {\n    // Initialize an empty array of odds per category.\n    var odds = {}, category;\n    // Iterate through each key in the item,\n    // then iterate through each category that has been used\n    // in previous calls to `.train()`\n    for (var k in item) {\n        var v = item[k];\n        for (category in this.data) {\n            // Create an empty object for storing key - value combinations\n            // for this category.\n            if (odds[category] === undefined) { odds[category] = {}; }\n\n            // If this item doesn't even have a property, it counts for nothing,\n            // but if it does have the property that we're looking for from\n            // the item to categorize, it counts based on how popular it is\n            // versus the whole population.\n            if (this.data[category][k]) {\n                odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount;\n            } else {\n                odds[category][k + '_' + v] = 0;\n            }\n        }\n    }\n\n    // Set up a new object that will contain sums of these odds by category\n    var oddsSums = {};\n\n    for (category in odds) {\n        // Tally all of the odds for each category-combination pair -\n        // the non-existence of a category does not add anything to the\n        // score.\n        for (var combination in odds[category]) {\n            if (oddsSums[category] === undefined) {\n                oddsSums[category] = 0;\n            }\n            oddsSums[category] += odds[category][combination];\n        }\n    }\n\n    return oddsSums;\n};\n\nmodule.exports = BayesianClassifier;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar binomialDistribution = require('./binomial_distribution');\n\n/**\n * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)\n * is the probability discrete\n * distribution of a random variable which takes value 1 with success\n * probability `p` and value 0 with failure\n * probability `q` = 1 - `p`. It can be used, for example, to represent the\n * toss of a coin, where \"1\" is defined to mean \"heads\" and \"0\" is defined\n * to mean \"tails\" (or vice versa). It is\n * a special case of a Binomial Distribution\n * where `n` = 1.\n *\n * @param {number} p input value, between 0 and 1 inclusive\n * @returns {number} value of bernoulli distribution at this point\n */\nfunction bernoulliDistribution(p) {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1)\n    if (p < 0 || p > 1 ) { return null; }\n\n    return binomialDistribution(1, p);\n}\n\nmodule.exports = bernoulliDistribution;\n\n},{\"./binomial_distribution\":5}],5:[function(require,module,exports){\n'use strict';\n\nvar epsilon = require('./epsilon');\nvar factorial = require('./factorial');\n\n/**\n * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability\n * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields\n * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or\n * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.\n *\n * @param {number} trials number of trials to simulate\n * @param {number} probability\n * @returns {number} output\n */\nfunction binomialDistribution(trials, probability) {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1),\n    // that `n` is an integer, strictly positive.\n    if (probability < 0 || probability > 1 ||\n        trials <= 0 || trials % 1 !== 0) {\n        return null;\n    }\n\n    // We initialize `x`, the random variable, and `accumulator`, an accumulator\n    // for the cumulative distribution function to 0. `distribution_functions`\n    // is the object we'll return with the `probability_of_x` and the\n    // `cumulativeProbability_of_x`, as well as the calculated mean &\n    // variance. We iterate until the `cumulativeProbability_of_x` is\n    // within `epsilon` of 1.0.\n    var x = 0,\n        cumulativeProbability = 0,\n        cells = {};\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = factorial(trials) /\n            (factorial(x) * factorial(trials - x)) *\n            (Math.pow(probability, x) * Math.pow(1 - probability, trials - x));\n        cumulativeProbability += cells[x];\n        x++;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = binomialDistribution;\n\n},{\"./epsilon\":11,\"./factorial\":13}],6:[function(require,module,exports){\n'use strict';\n\n/**\n * **Percentage Points of the χ2 (Chi-Squared) Distribution**\n *\n * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common\n * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two\n * criteria of classification of qualitative data, and in confidence interval estimation for a population standard\n * deviation of a normal distribution from a sample standard deviation.\n *\n * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, \"Probability and Statistics in\n * Engineering and Management Science\", Wiley (1980).\n */\nvar chiSquaredDistributionTable = {\n    1: { 0.995:  0.00, 0.99:  0.00, 0.975:  0.00, 0.95:  0.00, 0.9:  0.02, 0.5:  0.45, 0.1:  2.71, 0.05:  3.84, 0.025:  5.02, 0.01:  6.63, 0.005:  7.88 },\n    2: { 0.995:  0.01, 0.99:  0.02, 0.975:  0.05, 0.95:  0.10, 0.9:  0.21, 0.5:  1.39, 0.1:  4.61, 0.05:  5.99, 0.025:  7.38, 0.01:  9.21, 0.005: 10.60 },\n    3: { 0.995:  0.07, 0.99:  0.11, 0.975:  0.22, 0.95:  0.35, 0.9:  0.58, 0.5:  2.37, 0.1:  6.25, 0.05:  7.81, 0.025:  9.35, 0.01: 11.34, 0.005: 12.84 },\n    4: { 0.995:  0.21, 0.99:  0.30, 0.975:  0.48, 0.95:  0.71, 0.9:  1.06, 0.5:  3.36, 0.1:  7.78, 0.05:  9.49, 0.025: 11.14, 0.01: 13.28, 0.005: 14.86 },\n    5: { 0.995:  0.41, 0.99:  0.55, 0.975:  0.83, 0.95:  1.15, 0.9:  1.61, 0.5:  4.35, 0.1:  9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 0.005: 16.75 },\n    6: { 0.995:  0.68, 0.99:  0.87, 0.975:  1.24, 0.95:  1.64, 0.9:  2.20, 0.5:  5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 0.005: 18.55 },\n    7: { 0.995:  0.99, 0.99:  1.25, 0.975:  1.69, 0.95:  2.17, 0.9:  2.83, 0.5:  6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 0.005: 20.28 },\n    8: { 0.995:  1.34, 0.99:  1.65, 0.975:  2.18, 0.95:  2.73, 0.9:  3.49, 0.5:  7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 0.005: 21.96 },\n    9: { 0.995:  1.73, 0.99:  2.09, 0.975:  2.70, 0.95:  3.33, 0.9:  4.17, 0.5:  8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 0.005: 23.59 },\n    10: { 0.995:  2.16, 0.99:  2.56, 0.975:  3.25, 0.95:  3.94, 0.9:  4.87, 0.5:  9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 0.005: 25.19 },\n    11: { 0.995:  2.60, 0.99:  3.05, 0.975:  3.82, 0.95:  4.57, 0.9:  5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 0.005: 26.76 },\n    12: { 0.995:  3.07, 0.99:  3.57, 0.975:  4.40, 0.95:  5.23, 0.9:  6.30, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 0.005: 28.30 },\n    13: { 0.995:  3.57, 0.99:  4.11, 0.975:  5.01, 0.95:  5.89, 0.9:  7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 0.005: 29.82 },\n    14: { 0.995:  4.07, 0.99:  4.66, 0.975:  5.63, 0.95:  6.57, 0.9:  7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 0.005: 31.32 },\n    15: { 0.995:  4.60, 0.99:  5.23, 0.975:  6.27, 0.95:  7.26, 0.9:  8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25.00, 0.025: 27.49, 0.01: 30.58, 0.005: 32.80 },\n    16: { 0.995:  5.14, 0.99:  5.81, 0.975:  6.91, 0.95:  7.96, 0.9:  9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.30, 0.025: 28.85, 0.01: 32.00, 0.005: 34.27 },\n    17: { 0.995:  5.70, 0.99:  6.41, 0.975:  7.56, 0.95:  8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 0.005: 35.72 },\n    18: { 0.995:  6.26, 0.99:  7.01, 0.975:  8.23, 0.95:  9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 0.005: 37.16 },\n    19: { 0.995:  6.84, 0.99:  7.63, 0.975:  8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.20, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 0.005: 38.58 },\n    20: { 0.995:  7.43, 0.99:  8.26, 0.975:  9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 0.005: 40.00 },\n    21: { 0.995:  8.03, 0.99:  8.90, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 0.005: 41.40 },\n    22: { 0.995:  8.64, 0.99:  9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 0.005: 42.80 },\n    23: { 0.995:  9.26, 0.99: 10.20, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 0.005: 44.18 },\n    24: { 0.995:  9.89, 0.99: 10.86, 0.975: 12.40, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.20, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 0.005: 45.56 },\n    25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 0.005: 46.93 },\n    26: { 0.995: 11.16, 0.99: 12.20, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 0.005: 48.29 },\n    27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 0.005: 49.65 },\n    28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 0.005: 50.99 },\n    29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 0.005: 52.34 },\n    30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.60, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 0.005: 53.67 },\n    40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 0.005: 66.77 },\n    50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.50, 0.025: 71.42, 0.01: 76.15, 0.005: 79.49 },\n    60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.40, 0.05: 79.08, 0.025: 83.30, 0.01: 88.38, 0.005: 91.95 },\n    70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 0.005: 104.22 },\n    80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 0.005: 116.32 },\n    90: { 0.995: 59.20, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 0.005: 128.30 },\n    100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.50, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 0.005: 140.17 }\n};\n\nmodule.exports = chiSquaredDistributionTable;\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nvar mean = require('./mean');\nvar chiSquaredDistributionTable = require('./chi_squared_distribution_table');\n\n/**\n * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)\n * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies\n * (that is, counts of observations), each squared and divided by the number of observations expected given the\n * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution\n * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one\n * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic\n * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty\n * cells and `c` is the number of estimated parameters for the distribution.\n *\n * @param {Array<number>} data\n * @param {Function} distributionType a function that returns a point in a distribution:\n * for instance, binomial, bernoulli, or poisson\n * @param {number} significance\n * @returns {number} chi squared goodness of fit\n * @example\n * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,\n * // \"Probability and Statistics in Engineering and Management Science\", Wiley (1980).\n * var data1019 = [\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n *     2, 2, 2, 2, 2, 2, 2, 2, 2,\n *     3, 3, 3, 3\n * ];\n * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05)); //= false\n */\nfunction chiSquaredGoodnessOfFit(data, distributionType, significance) {\n    // Estimate from the sample data, a weighted mean.\n    var inputMean = mean(data),\n        // Calculated value of the χ2 statistic.\n        chiSquared = 0,\n        // Degrees of freedom, calculated as (number of class intervals -\n        // number of hypothesized distribution parameters estimated - 1)\n        degreesOfFreedom,\n        // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.\n        // Lose one degree of freedom for estimating `lambda` from the sample data.\n        c = 1,\n        // The hypothesized distribution.\n        // Generate the hypothesized distribution.\n        hypothesizedDistribution = distributionType(inputMean),\n        observedFrequencies = [],\n        expectedFrequencies = [],\n        k;\n\n    // Create an array holding a histogram from the sample data, of\n    // the form `{ value: numberOfOcurrences }`\n    for (var i = 0; i < data.length; i++) {\n        if (observedFrequencies[data[i]] === undefined) {\n            observedFrequencies[data[i]] = 0;\n        }\n        observedFrequencies[data[i]]++;\n    }\n\n    // The histogram we created might be sparse - there might be gaps\n    // between values. So we iterate through the histogram, making\n    // sure that instead of undefined, gaps have 0 values.\n    for (i = 0; i < observedFrequencies.length; i++) {\n        if (observedFrequencies[i] === undefined) {\n            observedFrequencies[i] = 0;\n        }\n    }\n\n    // Create an array holding a histogram of expected data given the\n    // sample size and hypothesized distribution.\n    for (k in hypothesizedDistribution) {\n        if (k in observedFrequencies) {\n            expectedFrequencies[k] = hypothesizedDistribution[k] * data.length;\n        }\n    }\n\n    // Working backward through the expected frequencies, collapse classes\n    // if less than three observations are expected for a class.\n    // This transformation is applied to the observed frequencies as well.\n    for (k = expectedFrequencies.length - 1; k >= 0; k--) {\n        if (expectedFrequencies[k] < 3) {\n            expectedFrequencies[k - 1] += expectedFrequencies[k];\n            expectedFrequencies.pop();\n\n            observedFrequencies[k - 1] += observedFrequencies[k];\n            observedFrequencies.pop();\n        }\n    }\n\n    // Iterate through the squared differences between observed & expected\n    // frequencies, accumulating the `chiSquared` statistic.\n    for (k = 0; k < observedFrequencies.length; k++) {\n        chiSquared += Math.pow(\n            observedFrequencies[k] - expectedFrequencies[k], 2) /\n            expectedFrequencies[k];\n    }\n\n    // Calculate degrees of freedom for this test and look it up in the\n    // `chiSquaredDistributionTable` in order to\n    // accept or reject the goodness-of-fit of the hypothesized distribution.\n    degreesOfFreedom = observedFrequencies.length - c - 1;\n    return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared;\n}\n\nmodule.exports = chiSquaredGoodnessOfFit;\n\n},{\"./chi_squared_distribution_table\":6,\"./mean\":22}],8:[function(require,module,exports){\n'use strict';\n\n/**\n * Split an array into chunks of a specified size. This function\n * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)\n * function, and thus will insert smaller-sized chunks at the end if\n * the input size is not divisible by the chunk size.\n *\n * `sample` is expected to be an array, and `chunkSize` a number.\n * The `sample` array can contain any kind of data.\n *\n * @param {Array} sample any array of values\n * @param {number} chunkSize size of each output array\n * @returns {Array<Array>} a chunked array\n * @example\n * console.log(chunk([1, 2, 3, 4], 2)); // [[1, 2], [3, 4]]\n */\nfunction chunk(sample, chunkSize) {\n\n    // a list of result chunks, as arrays in an array\n    var output = [];\n\n    // `chunkSize` must be zero or higher - otherwise the loop below,\n    // in which we call `start += chunkSize`, will loop infinitely.\n    // So, we'll detect and return null in that case to indicate\n    // invalid input.\n    if (chunkSize <= 0) {\n        return null;\n    }\n\n    // `start` is the index at which `.slice` will start selecting\n    // new array elements\n    for (var start = 0; start < sample.length; start += chunkSize) {\n\n        // for each chunk, slice that part of the array and add it\n        // to the output. The `.slice` function does not change\n        // the original array.\n        output.push(sample.slice(start, start + chunkSize));\n    }\n    return output;\n}\n\nmodule.exports = chunk;\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar sortedUniqueCount = require('./sorted_unique_count'),\n    numericSort = require('./numeric_sort');\n\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} columns\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\nfunction makeMatrix(columns, rows) {\n    var matrix = [];\n    for (var i = 0; i < columns; i++) {\n        var column = [];\n        for (var j = 0; j < rows; j++) {\n            column.push(0);\n        }\n        matrix.push(column);\n    }\n    return matrix;\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} data input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(data, nClusters) {\n\n    if (nClusters > data.length) {\n        throw new Error('Cannot generate more classes than there are data values');\n    }\n\n    var sorted = numericSort(data),\n        // we'll use this as the maximum number of clusters\n        uniqueCount = sortedUniqueCount(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n        return [sorted];\n    }\n\n    // named 'D' originally\n    var matrix = makeMatrix(nClusters, sorted.length),\n        // named 'B' originally\n        backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n\n    // The outer loop iterates through clusters, from 0 to nClusters.\n    for (var cluster = 0; cluster < nClusters; cluster++) {\n\n        // At the start of each loop, the mean starts as the first element\n        var firstClusterMean = sorted[0];\n\n        for (var sortedIdx = Math.max(cluster, 1);\n             sortedIdx < sorted.length;\n             sortedIdx++) {\n\n            if (cluster === 0) {\n\n                // Increase the running sum of squares calculation by this\n                // new value\n                var squaredDifference = Math.pow(\n                    sorted[sortedIdx] - firstClusterMean, 2);\n                matrix[cluster][sortedIdx] = matrix[cluster][sortedIdx - 1] +\n                    (sortedIdx / (sortedIdx + 1)) * squaredDifference;\n\n                // We're computing a running mean by taking the previous\n                // mean value, multiplying it by the number of elements\n                // seen so far, and then dividing it by the number of\n                // elements total.\n                var newSum = sortedIdx * firstClusterMean + sorted[sortedIdx];\n                firstClusterMean = newSum / (sortedIdx + 1);\n\n            } else {\n\n                var sumSquaredDistances = 0,\n                    meanXJ = 0;\n\n                for (var j = sortedIdx; j >= cluster; j--) {\n\n                    sumSquaredDistances += (sortedIdx - j) /\n                        (sortedIdx - j + 1) *\n                        Math.pow(sorted[j] - meanXJ, 2);\n\n                    meanXJ = (sorted[j] + (sortedIdx - j) * meanXJ) /\n                        (sortedIdx - j + 1);\n\n                    if (j === sortedIdx) {\n                        matrix[cluster][sortedIdx] = sumSquaredDistances;\n                        backtrackMatrix[cluster][sortedIdx] = j;\n                        if (j > 0) {\n                            matrix[cluster][sortedIdx] += matrix[cluster - 1][j - 1];\n                        }\n                    } else {\n                        if (j === 0) {\n                            if (sumSquaredDistances <= matrix[cluster][sortedIdx]) {\n                                matrix[cluster][sortedIdx] = sumSquaredDistances;\n                                backtrackMatrix[cluster][sortedIdx] = j;\n                            }\n                        } else if (sumSquaredDistances + matrix[cluster - 1][j - 1] < matrix[cluster][sortedIdx]) {\n                            matrix[cluster][sortedIdx] = sumSquaredDistances + matrix[cluster - 1][j - 1];\n                            backtrackMatrix[cluster][sortedIdx] = j;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    var clusters = [],\n        clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\n        var clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n        // fill the cluster from the sorted input by taking a slice of the\n        // array. the backtrack matrix makes this easy - it stores the\n        // indexes where the cluster should start and end.\n        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n        if (cluster > 0) {\n            clusterRight = clusterLeft - 1;\n        }\n    }\n\n    return clusters;\n}\n\nmodule.exports = ckmeans;\n\n},{\"./numeric_sort\":27,\"./sorted_unique_count\":43}],10:[function(require,module,exports){\n'use strict';\n\nvar standardNormalTable = require('./standard_normal_table');\n\n/**\n * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**\n *\n * Since probability tables cannot be\n * printed for every normal distribution, as there are an infinite variety\n * of normal distributions, it is common practice to convert a normal to a\n * standard normal and then use the standard normal table to find probabilities.\n *\n * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability\n * instead of looking it up in a table.\n *\n * @param {number} z\n * @returns {number} cumulative standard normal probability\n */\nfunction cumulativeStdNormalProbability(z) {\n\n    // Calculate the position of this value.\n    var absZ = Math.abs(z),\n        // Each row begins with a different\n        // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table\n        // corresponds to a range of 0.01 in the input values, so the value is\n        // multiplied by 100.\n        index = Math.min(Math.round(absZ * 100), standardNormalTable.length - 1);\n\n    // The index we calculate must be in the table as a positive value,\n    // but we still pay attention to whether the input is positive\n    // or negative, and flip the output value as a last step.\n    if (z >= 0) {\n        return standardNormalTable[index];\n    } else {\n        // due to floating-point arithmetic, values in the table with\n        // 4 significant figures can nevertheless end up as repeating\n        // fractions when they're computed here.\n        return +(1 - standardNormalTable[index]).toFixed(4);\n    }\n}\n\nmodule.exports = cumulativeStdNormalProbability;\n\n},{\"./standard_normal_table\":45}],11:[function(require,module,exports){\n'use strict';\n\n/**\n * We use `ε`, epsilon, as a stopping criterion when we want to iterate\n * until we're \"close enough\". Epsilon is a very small number: for\n * simple statistics, that number is **0.0001**\n *\n * This is used in calculations like the binomialDistribution, in which\n * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):\n * it progresses until it is close enough.\n *\n * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),\n * where we're trying to find a local minimum of a function's derivative,\n * given by the `fDerivative` method.\n *\n * @example\n * // From calculation, we expect that the local minimum occurs at x=9/4\n * var x_old = 0;\n * // The algorithm starts at x=6\n * var x_new = 6;\n * var stepSize = 0.01;\n *\n * function fDerivative(x) {\n *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);\n * }\n *\n * // The loop runs until the difference between the previous\n * // value and the current value is smaller than epsilon - a rough\n * // meaure of 'close enough'\n * while (Math.abs(x_new - x_old) > ss.epsilon) {\n *   x_old = x_new;\n *   x_new = x_old - stepSize * fDerivative(x_old);\n * }\n *\n * console.log('Local minimum occurs at', x_new);\n */\nvar epsilon = 0.0001;\n\nmodule.exports = epsilon;\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**\n *\n * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a\n * normal distribution with standard deviation sd is within x of the mean.\n *\n * This function returns a numerical approximation to the exact value.\n *\n * @param {number} x input\n * @return {number} error estimation\n * @example\n * errorFunction(1); //= 0.8427\n */\nfunction errorFunction(x) {\n    var t = 1 / (1 + 0.5 * Math.abs(x));\n    var tau = t * Math.exp(-Math.pow(x, 2) -\n        1.26551223 +\n        1.00002368 * t +\n        0.37409196 * Math.pow(t, 2) +\n        0.09678418 * Math.pow(t, 3) -\n        0.18628806 * Math.pow(t, 4) +\n        0.27886807 * Math.pow(t, 5) -\n        1.13520398 * Math.pow(t, 6) +\n        1.48851587 * Math.pow(t, 7) -\n        0.82215223 * Math.pow(t, 8) +\n        0.17087277 * Math.pow(t, 9));\n    if (x >= 0) {\n        return 1 - tau;\n    } else {\n        return tau - 1;\n    }\n}\n\nmodule.exports = errorFunction;\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\n/**\n * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive\n * integers less than or equal to n. Often factorial is implemented\n * recursively, but this iterative approach is significantly faster\n * and simpler.\n *\n * @param {number} n input\n * @returns {number} factorial: n!\n * @example\n * console.log(factorial(5)); // 120\n */\nfunction factorial(n) {\n\n    // factorial is mathematically undefined for negative numbers\n    if (n < 0 ) { return null; }\n\n    // typically you'll expand the factorial function going down, like\n    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,\n    // counting from 2 up to the number in question, and since anything\n    // multiplied by 1 is itself, the loop only needs to start at 2.\n    var accumulator = 1;\n    for (var i = 2; i <= n; i++) {\n        // for each number up to and including the number `n`, multiply\n        // the accumulator my that number.\n        accumulator *= i;\n    }\n    return accumulator;\n}\n\nmodule.exports = factorial;\n\n},{}],14:[function(require,module,exports){\n'use strict';\n\n/**\n * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is\n * a mean function that is more useful for numbers in different\n * ranges.\n *\n * This is the nth root of the input numbers multiplied by each other.\n *\n * The geometric mean is often useful for\n * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given\n * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple\n * mean will incorrectly estimate an average growth rate, whereas a geometric\n * mean will correctly estimate a growth rate that, over those years,\n * will yield the same end value.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input array\n * @returns {number} geometric mean\n * @example\n * var growthRates = [1.80, 1.166666, 1.428571];\n * var averageGrowth = geometricMean(growthRates);\n * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];\n * var startingValue = 10;\n * var startingValueMean = 10;\n * growthRates.forEach(function(rate) {\n *   startingValue *= rate;\n * });\n * averageGrowthRates.forEach(function(rate) {\n *   startingValueMean *= rate;\n * });\n * startingValueMean === startingValue;\n */\nfunction geometricMean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    // the starting value.\n    var value = 1;\n\n    for (var i = 0; i < x.length; i++) {\n        // the geometric mean is only valid for positive numbers\n        if (x[i] <= 0) { return null; }\n\n        // repeatedly multiply the value by each number\n        value *= x[i];\n    }\n\n    return Math.pow(value, 1 / x.length);\n}\n\nmodule.exports = geometricMean;\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is\n * a mean function typically used to find the average of rates.\n * This mean is calculated by taking the reciprocal of the arithmetic mean\n * of the reciprocals of the input numbers.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @returns {number} harmonic mean\n * @example\n * ss.harmonicMean([2, 3]) //= 2.4\n */\nfunction harmonicMean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    var reciprocalSum = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        // the harmonic mean is only valid for positive numbers\n        if (x[i] <= 0) { return null; }\n\n        reciprocalSum += 1 / x[i];\n    }\n\n    // divide n by the the reciprocal sum\n    return x.length / reciprocalSum;\n}\n\nmodule.exports = harmonicMean;\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nvar quantile = require('./quantile');\n\n/**\n * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is\n * a measure of statistical dispersion, or how scattered, spread, or\n * concentrated a distribution is. It's computed as the difference between\n * the third quartile and first quartile.\n *\n * @param {Array<number>} sample\n * @returns {number} interquartile range: the span between lower and upper quartile,\n * 0.25 and 0.75\n * @example\n * interquartileRange([0, 1, 2, 3]); //= 2\n */\nfunction interquartileRange(sample) {\n    // We can't derive quantiles from an empty list\n    if (sample.length === 0) { return null; }\n\n    // Interquartile range is the span between the upper quartile,\n    // at `0.75`, and lower quartile, `0.25`\n    return quantile(sample, 0.75) - quantile(sample, 0.25);\n}\n\nmodule.exports = interquartileRange;\n\n},{\"./quantile\":31}],17:[function(require,module,exports){\n'use strict';\n\n/**\n * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)\n * returns a numerical approximation to the value that would have caused\n * `errorFunction()` to return x.\n *\n * @param {number} x value of error function\n * @returns {number} estimated inverted value\n */\nfunction inverseErrorFunction(x) {\n    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));\n\n    var inv = Math.sqrt(Math.sqrt(\n        Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -\n        Math.log(1 - x * x) / a) -\n        (2 / (Math.PI * a) + Math.log(1 - x * x) / 2));\n\n    if (x >= 0) {\n        return inv;\n    } else {\n        return -inv;\n    }\n}\n\nmodule.exports = inverseErrorFunction;\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\n/**\n * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)\n * is a simple way to find a fitted line\n * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line\n * using the least sum of squares.\n *\n * @param {Array<Array<number>>} data an array of two-element of arrays,\n * like `[[0, 1], [2, 3]]`\n * @returns {Object} object containing slope and intersect of regression line\n * @example\n * linearRegression([[0, 0], [1, 1]]); // { m: 1, b: 0 }\n */\nfunction linearRegression(data) {\n\n    var m, b;\n\n    // Store data length in a local variable to reduce\n    // repeated object property lookups\n    var dataLength = data.length;\n\n    //if there's only one point, arbitrarily choose a slope of 0\n    //and a y-intercept of whatever the y of the initial point is\n    if (dataLength === 1) {\n        m = 0;\n        b = data[0][1];\n    } else {\n        // Initialize our sums and scope the `m` and `b`\n        // variables that define the line.\n        var sumX = 0, sumY = 0,\n            sumXX = 0, sumXY = 0;\n\n        // Use local variables to grab point values\n        // with minimal object property lookups\n        var point, x, y;\n\n        // Gather the sum of all x values, the sum of all\n        // y values, and the sum of x^2 and (x*y) for each\n        // value.\n        //\n        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy\n        for (var i = 0; i < dataLength; i++) {\n            point = data[i];\n            x = point[0];\n            y = point[1];\n\n            sumX += x;\n            sumY += y;\n\n            sumXX += x * x;\n            sumXY += x * y;\n        }\n\n        // `m` is the slope of the regression line\n        m = ((dataLength * sumXY) - (sumX * sumY)) /\n            ((dataLength * sumXX) - (sumX * sumX));\n\n        // `b` is the y-intercept of the line.\n        b = (sumY / dataLength) - ((m * sumX) / dataLength);\n    }\n\n    // Return both values as an object.\n    return {\n        m: m,\n        b: b\n    };\n}\n\n\nmodule.exports = linearRegression;\n\n},{}],19:[function(require,module,exports){\n'use strict';\n\n/**\n * Given the output of `linearRegression`: an object\n * with `m` and `b` values indicating slope and intercept,\n * respectively, generate a line function that translates\n * x values into y values.\n *\n * @param {Object} mb object with `m` and `b` members, representing\n * slope and intersect of desired line\n * @returns {Function} method that computes y-value at any given\n * x-value on the line.\n * @example\n * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));\n * l(0) //= 0\n * l(2) //= 2\n */\nfunction linearRegressionLine(mb) {\n    // Return a function that computes a `y` value for each\n    // x value it is given, based on the values of `b` and `a`\n    // that we just computed.\n    return function(x) {\n        return mb.b + (mb.m * x);\n    };\n}\n\nmodule.exports = linearRegressionLine;\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nvar median = require('./median');\n\n/**\n * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is\n * a robust measure of statistical\n * dispersion. It is more resilient to outliers than the standard deviation.\n *\n * @param {Array<number>} x input array\n * @returns {number} median absolute deviation\n * @example\n * mad([1, 1, 2, 2, 4, 6, 9]); //= 1\n */\nfunction mad(x) {\n    // The mad of nothing is null\n    if (!x || x.length === 0) { return null; }\n\n    var medianValue = median(x),\n        medianAbsoluteDeviations = [];\n\n    // Make a list of absolute deviations from the median\n    for (var i = 0; i < x.length; i++) {\n        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));\n    }\n\n    // Find the median value of that list\n    return median(medianAbsoluteDeviations);\n}\n\nmodule.exports = mad;\n\n},{\"./median\":23}],21:[function(require,module,exports){\n'use strict';\n\n/**\n * This computes the maximum number in an array.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} maximum value\n * @example\n * console.log(max([1, 2, 3, 4])); // 4\n */\nfunction max(x) {\n    var value;\n    for (var i = 0; i < x.length; i++) {\n        // On the first iteration of this loop, max is\n        // undefined and is thus made the maximum element in the array\n        if (x[i] > value || value === undefined) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = max;\n\n},{}],22:[function(require,module,exports){\n'use strict';\n\nvar sum = require('./sum');\n\n/**\n * The mean, _also known as average_,\n * is the sum of all values over the number of values.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input values\n * @returns {number} mean\n * @example\n * console.log(mean([0, 10])); // 5\n */\nfunction mean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    return sum(x) / x.length;\n}\n\nmodule.exports = mean;\n\n},{\"./sum\":46}],23:[function(require,module,exports){\n'use strict';\n\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [median](http://en.wikipedia.org/wiki/Median) is\n * the middle number of a list. This is often a good indicator of 'the middle'\n * when there are outliers that skew the `mean()` value.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * The median isn't necessarily one of the elements in the list: the value\n * can be the average of two elements if the list has an even length\n * and the two central values are different.\n *\n * @param {Array<number>} x input\n * @returns {number} median value\n * @example\n * var incomes = [10, 2, 5, 100, 2, 1];\n * median(incomes); //= 3.5\n */\nfunction median(x) {\n    // The median of an empty list is null\n    if (x.length === 0) { return null; }\n\n    // Sorting the array makes it easy to find the center, but\n    // use `.slice()` to ensure the original array `x` is not modified\n    var sorted = numericSort(x);\n\n    // If the length of the list is odd, it's the central number\n    if (sorted.length % 2 === 1) {\n        return sorted[(sorted.length - 1) / 2];\n    // Otherwise, the median is the average of the two numbers\n    // at the center of the list\n    } else {\n        var a = sorted[sorted.length / 2 - 1];\n        var b = sorted[sorted.length / 2];\n        return (a + b) / 2;\n    }\n}\n\nmodule.exports = median;\n\n},{\"./numeric_sort\":27}],24:[function(require,module,exports){\n'use strict';\n\n/**\n * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} minimum value\n * @example\n * min([1, 5, -10, 100, 2]); // -100\n */\nfunction min(x) {\n    var value;\n    for (var i = 0; i < x.length; i++) {\n        // On the first iteration of this loop, min is\n        // undefined and is thus made the minimum element in the array\n        if (x[i] < value || value === undefined) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = min;\n\n},{}],25:[function(require,module,exports){\n'use strict';\n\n/**\n * **Mixin** simple_statistics to a single Array instance if provided\n * or the Array native object if not. This is an optional\n * feature that lets you treat simple_statistics as a native feature\n * of Javascript.\n *\n * @param {Object} ss simple statistics\n * @param {Array} [array=] a single array instance which will be augmented\n * with the extra methods. If omitted, mixin will apply to all arrays\n * by changing the global `Array.prototype`.\n * @returns {*} the extended Array, or Array.prototype if no object\n * is given.\n *\n * @example\n * var myNumbers = [1, 2, 3];\n * mixin(ss, myNumbers);\n * console.log(myNumbers.sum()); // 6\n */\nfunction mixin(ss, array) {\n    var support = !!(Object.defineProperty && Object.defineProperties);\n    // Coverage testing will never test this error.\n    /* istanbul ignore next */\n    if (!support) {\n        throw new Error('without defineProperty, simple-statistics cannot be mixed in');\n    }\n\n    // only methods which work on basic arrays in a single step\n    // are supported\n    var arrayMethods = ['median', 'standardDeviation', 'sum',\n        'sampleSkewness',\n        'mean', 'min', 'max', 'quantile', 'geometricMean',\n        'harmonicMean', 'root_mean_square'];\n\n    // create a closure with a method name so that a reference\n    // like `arrayMethods[i]` doesn't follow the loop increment\n    function wrap(method) {\n        return function() {\n            // cast any arguments into an array, since they're\n            // natively objects\n            var args = Array.prototype.slice.apply(arguments);\n            // make the first argument the array itself\n            args.unshift(this);\n            // return the result of the ss method\n            return ss[method].apply(ss, args);\n        };\n    }\n\n    // select object to extend\n    var extending;\n    if (array) {\n        // create a shallow copy of the array so that our internal\n        // operations do not change it by reference\n        extending = array.slice();\n    } else {\n        extending = Array.prototype;\n    }\n\n    // for each array function, define a function that gets\n    // the array as the first argument.\n    // We use [defineProperty](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty)\n    // because it allows these properties to be non-enumerable:\n    // `for (var in x)` loops will not run into problems with this\n    // implementation.\n    for (var i = 0; i < arrayMethods.length; i++) {\n        Object.defineProperty(extending, arrayMethods[i], {\n            value: wrap(arrayMethods[i]),\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n\n    return extending;\n}\n\nmodule.exports = mixin;\n\n},{}],26:[function(require,module,exports){\n'use strict';\n\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @returns {number} mode\n * @example\n * mode([0, 0, 1]); //= 0\n */\nfunction mode(x) {\n\n    // Handle edge cases:\n    // The median of an empty list is null\n    if (x.length === 0) { return null; }\n    else if (x.length === 1) { return x[0]; }\n\n    // Sorting the array lets us iterate through it below and be sure\n    // that every time we see a new number it's new and we'll never\n    // see the same number twice\n    var sorted = numericSort(x);\n\n    // This assumes it is dealing with an array of size > 1, since size\n    // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n    // array.\n    var last = sorted[0],\n        // store the mode as we find new modes\n        value,\n        // store how many times we've seen the mode\n        maxSeen = 0,\n        // how many times the current candidate for the mode\n        // has been seen\n        seenThis = 1;\n\n    // end at sorted.length + 1 to fix the case in which the mode is\n    // the highest number that occurs in the sequence. the last iteration\n    // compares sorted[i], which is undefined, to the highest number\n    // in the series\n    for (var i = 1; i < sorted.length + 1; i++) {\n        // we're seeing a new number pass by\n        if (sorted[i] !== last) {\n            // the last number is the new mode since we saw it more\n            // often than the old one\n            if (seenThis > maxSeen) {\n                maxSeen = seenThis;\n                value = last;\n            }\n            seenThis = 1;\n            last = sorted[i];\n        // if this isn't a new number, it's one more occurrence of\n        // the potential mode\n        } else { seenThis++; }\n    }\n    return value;\n}\n\nmodule.exports = mode;\n\n},{\"./numeric_sort\":27}],27:[function(require,module,exports){\n'use strict';\n\n/**\n * Sort an array of numbers by their numeric value, ensuring that the\n * array is not changed in place.\n *\n * This is necessary because the default behavior of .sort\n * in JavaScript is to sort arrays as string values\n *\n *     [1, 10, 12, 102, 20].sort()\n *     // output\n *     [1, 10, 102, 12, 20]\n *\n * @param {Array<number>} array input array\n * @return {Array<number>} sorted array\n * @private\n * @example\n * numericSort([3, 2, 1]) // [1, 2, 3]\n */\nfunction numericSort(array) {\n    return array\n        // ensure the array is changed in-place\n        .slice()\n        // comparator function that treats input as numeric\n        .sort(function(a, b) {\n            return a - b;\n        });\n}\n\nmodule.exports = numericSort;\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\n/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nfunction PerceptronModel() {\n    // The weights, or coefficients of the model;\n    // weights are only populated when training with data.\n    this.weights = [];\n    // The bias term, or intercept; it is also a weight but\n    // it's stored separately for convenience as it is always\n    // multiplied by one.\n    this.bias = 0;\n}\n\n/**\n * **Predict**: Use an array of features with the weight array and bias\n * to predict whether an example is labeled 0 or 1.\n *\n * @param {Array<number>} features an array of features as numbers\n * @returns {number} 1 if the score is over 0, otherwise 0\n */\nPerceptronModel.prototype.predict = function(features) {\n\n    // Only predict if previously trained\n    // on the same size feature array(s).\n    if (features.length !== this.weights.length) { return null; }\n\n    // Calculate the sum of features times weights,\n    // with the bias added (implicitly times one).\n    var score = 0;\n    for (var i = 0; i < this.weights.length; i++) {\n        score += this.weights[i] * features[i];\n    }\n    score += this.bias;\n\n    // Classify as 1 if the score is over 0, otherwise 0.\n    if (score > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * **Train** the classifier with a new example, which is\n * a numeric array of features and a 0 or 1 label.\n *\n * @param {Array<number>} features an array of features as numbers\n * @param {number} label either 0 or 1\n * @returns {PerceptronModel} this\n */\nPerceptronModel.prototype.train = function(features, label) {\n    // Require that only labels of 0 or 1 are considered.\n    if (label !== 0 && label !== 1) { return null; }\n    // The length of the feature array determines\n    // the length of the weight array.\n    // The perceptron will continue learning as long as\n    // it keeps seeing feature arrays of the same length.\n    // When it sees a new data shape, it initializes.\n    if (features.length !== this.weights.length) {\n        this.weights = features;\n        this.bias = 1;\n    }\n    // Make a prediction based on current weights.\n    var prediction = this.predict(features);\n    // Update the weights if the prediction is wrong.\n    if (prediction !== label) {\n        var gradient = label - prediction;\n        for (var i = 0; i < this.weights.length; i++) {\n            this.weights[i] += gradient * features[i];\n        }\n        this.bias += gradient;\n    }\n    return this;\n};\n\nmodule.exports = PerceptronModel;\n\n},{}],29:[function(require,module,exports){\n'use strict';\n\nvar epsilon = require('./epsilon');\nvar factorial = require('./factorial');\n\n/**\n * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)\n * is a discrete probability distribution that expresses the probability\n * of a given number of events occurring in a fixed interval of time\n * and/or space if these events occur with a known average rate and\n * independently of the time since the last event.\n *\n * The Poisson Distribution is characterized by the strictly positive\n * mean arrival or occurrence rate, `λ`.\n *\n * @param {number} lambda location poisson distribution\n * @returns {number} value of poisson distribution at that point\n */\nfunction poissonDistribution(lambda) {\n    // Check that lambda is strictly positive\n    if (lambda <= 0) { return null; }\n\n    // our current place in the distribution\n    var x = 0,\n        // and we keep track of the current cumulative probability, in\n        // order to know when to stop calculating chances.\n        cumulativeProbability = 0,\n        // the calculated cells to be returned\n        cells = {};\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = (Math.pow(Math.E, -lambda) * Math.pow(lambda, x)) / factorial(x);\n        cumulativeProbability += cells[x];\n        x++;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = poissonDistribution;\n\n},{\"./epsilon\":11,\"./factorial\":13}],30:[function(require,module,exports){\n'use strict';\n\nvar epsilon = require('./epsilon');\nvar inverseErrorFunction = require('./inverse_error_function');\n\n/**\n * The [Probit](http://en.wikipedia.org/wiki/Probit)\n * is the inverse of cumulativeStdNormalProbability(),\n * and is also known as the normal quantile function.\n *\n * It returns the number of standard deviations from the mean\n * where the p'th quantile of values can be found in a normal distribution.\n * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are\n * normally found within 1 standard deviation above or below the mean.\n *\n * @param {number} p\n * @returns {number} probit\n */\nfunction probit(p) {\n    if (p === 0) {\n        p = epsilon;\n    } else if (p >= 1) {\n        p = 1 - epsilon;\n    }\n    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);\n}\n\nmodule.exports = probit;\n\n},{\"./epsilon\":11,\"./inverse_error_function\":17}],31:[function(require,module,exports){\n'use strict';\n\nvar quantileSorted = require('./quantile_sorted');\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} sample a sample from the population\n * @param {number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * var data = [3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20];\n * quantile(data, 1); //= max(data);\n * quantile(data, 0); //= min(data);\n * quantile(data, 0.5); //= 9\n */\nfunction quantile(sample, p) {\n\n    // We can't derive quantiles from an empty list\n    if (sample.length === 0) { return null; }\n\n    // Sort a copy of the array. We'll need a sorted array to index\n    // the values in sorted order.\n    var sorted = numericSort(sample);\n\n    if (p.length) {\n        // Initialize the result array\n        var results = [];\n        // For each requested quantile\n        for (var i = 0; i < p.length; i++) {\n            results[i] = quantileSorted(sorted, p[i]);\n        }\n        return results;\n    } else {\n        return quantileSorted(sorted, p);\n    }\n}\n\nmodule.exports = quantile;\n\n},{\"./numeric_sort\":27,\"./quantile_sorted\":32}],32:[function(require,module,exports){\n'use strict';\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} sample input data\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @example\n * var data = [3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20];\n * quantileSorted(data, 1); //= max(data);\n * quantileSorted(data, 0); //= min(data);\n * quantileSorted(data, 0.5); //= 9\n */\nfunction quantileSorted(sample, p) {\n    var idx = sample.length * p;\n    if (p < 0 || p > 1) {\n        return null;\n    } else if (p === 1) {\n        // If p is 1, directly return the last element\n        return sample[sample.length - 1];\n    } else if (p === 0) {\n        // If p is 0, directly return the first element\n        return sample[0];\n    } else if (idx % 1 !== 0) {\n        // If p is not integer, return the next element in array\n        return sample[Math.ceil(idx) - 1];\n    } else if (sample.length % 2 === 0) {\n        // If the list has even-length, we'll take the average of this number\n        // and the next value, if there is one\n        return (sample[idx - 1] + sample[idx]) / 2;\n    } else {\n        // Finally, in the simple case of an integer value\n        // with an odd-length list, return the sample value at the index.\n        return sample[idx];\n    }\n}\n\nmodule.exports = quantileSorted;\n\n},{}],33:[function(require,module,exports){\n'use strict';\n\n/**\n * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)\n * value of data compared with a function `f`\n * is the sum of the squared differences between the prediction\n * and the actual value.\n *\n * @param {Array<Array<number>>} data input data: this should be doubly-nested\n * @param {Function} func function called on `[i][0]` values within the dataset\n * @returns {number} r-squared value\n * @example\n * var samples = [[0, 0], [1, 1]];\n * var regressionLine = linearRegressionLine(linearRegression(samples));\n * rSquared(samples, regressionLine); //= 1 this line is a perfect fit\n */\nfunction rSquared(data, func) {\n    if (data.length < 2) { return 1; }\n\n    // Compute the average y value for the actual\n    // data set in order to compute the\n    // _total sum of squares_\n    var sum = 0, average;\n    for (var i = 0; i < data.length; i++) {\n        sum += data[i][1];\n    }\n    average = sum / data.length;\n\n    // Compute the total sum of squares - the\n    // squared difference between each point\n    // and the average of all points.\n    var sumOfSquares = 0;\n    for (var j = 0; j < data.length; j++) {\n        sumOfSquares += Math.pow(average - data[j][1], 2);\n    }\n\n    // Finally estimate the error: the squared\n    // difference between the estimate and the actual data\n    // value at each point.\n    var err = 0;\n    for (var k = 0; k < data.length; k++) {\n        err += Math.pow(data[k][1] - func(data[k][0]), 2);\n    }\n\n    // As the error grows larger, its ratio to the\n    // sum of squares increases and the r squared\n    // value grows lower.\n    return 1 - err / sumOfSquares;\n}\n\nmodule.exports = rSquared;\n\n},{}],34:[function(require,module,exports){\n'use strict';\n\n/**\n * The Root Mean Square (RMS) is\n * a mean function used as a measure of the magnitude of a set\n * of numbers, regardless of their sign.\n * This is the square root of the mean of the squares of the\n * input numbers.\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} root mean square\n * @example\n * rootMeanSquare([-1, 1, -1, 1]); //= 1\n */\nfunction rootMeanSquare(x) {\n    if (x.length === 0) { return null; }\n\n    var sumOfSquares = 0;\n    for (var i = 0; i < x.length; i++) {\n        sumOfSquares += Math.pow(x[i], 2);\n    }\n\n    return Math.sqrt(sumOfSquares / x.length);\n}\n\nmodule.exports = rootMeanSquare;\n\n},{}],35:[function(require,module,exports){\n'use strict';\n\nvar shuffle = require('./shuffle');\n\n/**\n * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)\n * from a given array of `n` elements.\n *\n * The sampled values will be in any order, not necessarily the order\n * they appear in the input.\n *\n * @param {Array} array input array. can contain any type\n * @param {number} n count of how many elements to take\n * @param {Function} [randomSource=Math.random] an optional source of entropy\n * instead of Math.random\n * @return {Array} subset of n elements in original array\n * @example\n * var values = [1, 2, 4, 5, 6, 7, 8, 9];\n * sample(values, 3); // returns 3 random values, like [2, 5, 8];\n */\nfunction sample(array, n, randomSource) {\n    // shuffle the original array using a fisher-yates shuffle\n    var shuffled = shuffle(array, randomSource);\n\n    // and then return a subset of it - the first `n` elements.\n    return shuffled.slice(0, n);\n}\n\nmodule.exports = sample;\n\n},{\"./shuffle\":41}],36:[function(require,module,exports){\n'use strict';\n\nvar sampleCovariance = require('./sample_covariance');\nvar sampleStandardDeviation = require('./sample_standard_deviation');\n\n/**\n * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is\n * a measure of how correlated two datasets are, between -1 and 1\n *\n * @param {Array<number>} x first input\n * @param {Array<number>} y second input\n * @returns {number} sample correlation\n * @example\n * var a = [1, 2, 3, 4, 5, 6];\n * var b = [2, 2, 3, 4, 5, 60];\n * sampleCorrelation(a, b); //= 0.691\n */\nfunction sampleCorrelation(x, y) {\n    var cov = sampleCovariance(x, y),\n        xstd = sampleStandardDeviation(x),\n        ystd = sampleStandardDeviation(y);\n\n    if (cov === null || xstd === null || ystd === null) {\n        return null;\n    }\n\n    return cov / xstd / ystd;\n}\n\nmodule.exports = sampleCorrelation;\n\n},{\"./sample_covariance\":37,\"./sample_standard_deviation\":39}],37:[function(require,module,exports){\n'use strict';\n\nvar mean = require('./mean');\n\n/**\n * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:\n * how much do the two datasets move together?\n * x and y are two datasets, represented as arrays of numbers.\n *\n * @param {Array<number>} x first input\n * @param {Array<number>} y second input\n * @returns {number} sample covariance\n * @example\n * var x = [1, 2, 3, 4, 5, 6];\n * var y = [6, 5, 4, 3, 2, 1];\n * sampleCovariance(x, y); //= -3.5\n */\nfunction sampleCovariance(x, y) {\n\n    // The two datasets must have the same length which must be more than 1\n    if (x.length <= 1 || x.length !== y.length) {\n        return null;\n    }\n\n    // determine the mean of each dataset so that we can judge each\n    // value of the dataset fairly as the difference from the mean. this\n    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance\n    // does not suffer because of the difference in absolute values\n    var xmean = mean(x),\n        ymean = mean(y),\n        sum = 0;\n\n    // for each pair of values, the covariance increases when their\n    // difference from the mean is associated - if both are well above\n    // or if both are well below\n    // the mean, the covariance increases significantly.\n    for (var i = 0; i < x.length; i++) {\n        sum += (x[i] - xmean) * (y[i] - ymean);\n    }\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // the covariance is weighted by the length of the datasets.\n    return sum / besselsCorrection;\n}\n\nmodule.exports = sampleCovariance;\n\n},{\"./mean\":22}],38:[function(require,module,exports){\n'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\nvar sampleStandardDeviation = require('./sample_standard_deviation');\n\n/**\n * [Skewness](http://en.wikipedia.org/wiki/Skewness) is\n * a measure of the extent to which a probability distribution of a\n * real-valued random variable \"leans\" to one side of the mean.\n * The skewness value can be positive or negative, or even undefined.\n *\n * Implementation is based on the adjusted Fisher-Pearson standardized\n * moment coefficient, which is the version found in Excel and several\n * statistical packages including Minitab, SAS and SPSS.\n *\n * @param {Array<number>} x input\n * @returns {number} sample skewness\n * @example\n * var data = [2, 4, 6, 3, 1];\n * sampleSkewness(data); //= 0.5901286564\n */\nfunction sampleSkewness(x) {\n    // The skewness of less than three arguments is null\n    if (x.length < 3) { return null; }\n\n    var n = x.length,\n        cubedS = Math.pow(sampleStandardDeviation(x), 3),\n        sumCubedDeviations = sumNthPowerDeviations(x, 3);\n\n    return n * sumCubedDeviations / ((n - 1) * (n - 2) * cubedS);\n}\n\nmodule.exports = sampleSkewness;\n\n},{\"./sample_standard_deviation\":39,\"./sum_nth_power_deviations\":47}],39:[function(require,module,exports){\n'use strict';\n\nvar sampleVariance = require('./sample_variance');\n\n/**\n * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n * is the square root of the variance.\n *\n * @param {Array<number>} x input array\n * @returns {number} sample standard deviation\n * @example\n * ss.sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]);\n * //= 2.138\n */\nfunction sampleStandardDeviation(x) {\n    // The standard deviation of no numbers is null\n    if (x.length <= 1) { return null; }\n\n    return Math.sqrt(sampleVariance(x));\n}\n\nmodule.exports = sampleStandardDeviation;\n\n},{\"./sample_variance\":40}],40:[function(require,module,exports){\n'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\n\n/*\n * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)\n * is the sum of squared deviations from the mean. The sample variance\n * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):\n * instead of dividing the sum of squared deviations by the length of the input,\n * it is divided by the length minus one. This corrects the bias in estimating\n * a value from a set that you don't know if full.\n *\n * References:\n * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)\n *\n * @param {Array<number>} x input array\n * @return {number} sample variance\n * @example\n * sampleVariance([1, 2, 3, 4, 5]); //= 2.5\n */\nfunction sampleVariance(x) {\n    // The variance of no numbers is null\n    if (x.length <= 1) { return null; }\n\n    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // Find the mean value of that list\n    return sumSquaredDeviationsValue / besselsCorrection;\n}\n\nmodule.exports = sampleVariance;\n\n},{\"./sum_nth_power_deviations\":47}],41:[function(require,module,exports){\n'use strict';\n\nvar shuffleInPlace = require('./shuffle_in_place');\n\n/*\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * is a fast way to create a random permutation of a finite set. This is\n * a function around `shuffle_in_place` that adds the guarantee that\n * it will not modify its input.\n *\n * @param {Array} sample an array of any kind of element\n * @param {Function} [randomSource=Math.random] an optional entropy source\n * @return {Array} shuffled version of input\n * @example\n * var shuffled = shuffle([1, 2, 3, 4]);\n * shuffled; // = [2, 3, 1, 4] or any other random permutation\n */\nfunction shuffle(sample, randomSource) {\n    // slice the original array so that it is not modified\n    sample = sample.slice();\n\n    // and then shuffle that shallow-copied array, in place\n    return shuffleInPlace(sample.slice(), randomSource);\n}\n\nmodule.exports = shuffle;\n\n},{\"./shuffle_in_place\":42}],42:[function(require,module,exports){\n'use strict';\n\n/*\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * in-place - which means that it **will change the order of the original\n * array by reference**.\n *\n * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)\n * of a set.\n *\n * @param {Array} sample input array\n * @param {Function} [randomSource=Math.random] an optional source of entropy\n * @returns {Array} sample\n * @example\n * var sample = [1, 2, 3, 4];\n * shuffleInPlace(sample);\n * // sample is shuffled to a value like [2, 1, 4, 3]\n */\nfunction shuffleInPlace(sample, randomSource) {\n\n    // a custom random number source can be provided if you want to use\n    // a fixed seed or another random number generator, like\n    // [random-js](https://www.npmjs.org/package/random-js)\n    randomSource = randomSource || Math.random;\n\n    // store the current length of the sample to determine\n    // when no elements remain to shuffle.\n    var length = sample.length;\n\n    // temporary is used to hold an item when it is being\n    // swapped between indices.\n    var temporary;\n\n    // The index to swap at each stage.\n    var index;\n\n    // While there are still items to shuffle\n    while (length > 0) {\n        // chose a random index within the subset of the array\n        // that is not yet shuffled\n        index = Math.floor(randomSource() * length--);\n\n        // store the value that we'll move temporarily\n        temporary = sample[length];\n\n        // swap the value at `sample[length]` with `sample[index]`\n        sample[length] = sample[index];\n        sample[index] = temporary;\n    }\n\n    return sample;\n}\n\nmodule.exports = shuffleInPlace;\n\n},{}],43:[function(require,module,exports){\n'use strict';\n\n/**\n * For a sorted input, counting the number of unique values\n * is possible in constant time and constant memory. This is\n * a simple implementation of the algorithm.\n *\n * Values are compared with `===`, so objects and non-primitive objects\n * are not handled in any special way.\n *\n * @param {Array} input an array of primitive values.\n * @returns {number} count of unique values\n * @example\n * sortedUniqueCount([1, 2, 3]); // 3\n * sortedUniqueCount([1, 1, 1]); // 1\n */\nfunction sortedUniqueCount(input) {\n    var uniqueValueCount = 0,\n        lastSeenValue;\n    for (var i = 0; i < input.length; i++) {\n        if (i === 0 || input[i] !== lastSeenValue) {\n            lastSeenValue = input[i];\n            uniqueValueCount++;\n        }\n    }\n    return uniqueValueCount;\n}\n\nmodule.exports = sortedUniqueCount;\n\n},{}],44:[function(require,module,exports){\n'use strict';\n\nvar variance = require('./variance');\n\n/**\n * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n * is the square root of the variance. It's useful for measuring the amount\n * of variation or dispersion in a set of values.\n *\n * Standard deviation is only appropriate for full-population knowledge: for\n * samples of a population, {@link sampleStandardDeviation} is\n * more appropriate.\n *\n * @param {Array<number>} x input\n * @returns {number} standard deviation\n * @example\n * var scores = [2, 4, 4, 4, 5, 5, 7, 9];\n * variance(scores); //= 4\n * standardDeviation(scores); //= 2\n */\nfunction standardDeviation(x) {\n    // The standard deviation of no numbers is null\n    if (x.length === 0) { return null; }\n\n    return Math.sqrt(variance(x));\n}\n\nmodule.exports = standardDeviation;\n\n},{\"./variance\":50}],45:[function(require,module,exports){\n'use strict';\n\nvar SQRT_2PI = Math.sqrt(2 * Math.PI);\n\nfunction cumulativeDistribution(z) {\n    var sum = z,\n        tmp = z;\n\n    // 15 iterations are enough for 4-digit precision\n    for (var i = 1; i < 15; i++) {\n        tmp *= z * z / (2 * i + 1);\n        sum += tmp;\n    }\n    return Math.round((0.5 + (sum / SQRT_2PI) * Math.exp(-z * z / 2)) * 1e4) / 1e4;\n}\n\n/**\n * A standard normal table, also called the unit normal table or Z table,\n * is a mathematical table for the values of Φ (phi), which are the values of\n * the cumulative distribution function of the normal distribution.\n * It is used to find the probability that a statistic is observed below,\n * above, or between values on the standard normal distribution, and by\n * extension, any normal distribution.\n *\n * The probabilities are calculated using the\n * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).\n * The table used is the cumulative, and not cumulative from 0 to mean\n * (even though the latter has 5 digits precision, instead of 4).\n */\nvar standardNormalTable = [];\n\nfor (var z = 0; z <= 3.09; z += 0.01) {\n    standardNormalTable.push(cumulativeDistribution(z));\n}\n\nmodule.exports = standardNormalTable;\n\n},{}],46:[function(require,module,exports){\n'use strict';\n\n/**\n * The [sum](https://en.wikipedia.org/wiki/Summation) of an array\n * is the result of adding all numbers together, starting from zero.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * console.log(sum([1, 2, 3])); // 6\n */\nfunction sum(x) {\n    var value = 0;\n    for (var i = 0; i < x.length; i++) {\n        value += x[i];\n    }\n    return value;\n}\n\nmodule.exports = sum;\n\n},{}],47:[function(require,module,exports){\n'use strict';\n\nvar mean = require('./mean');\n\n/**\n * The sum of deviations to the Nth power.\n * When n=2 it's the sum of squared deviations.\n * When n=3 it's the sum of cubed deviations.\n *\n * @param {Array<number>} x\n * @param {number} n power\n * @returns {number} sum of nth power deviations\n * @example\n * var input = [1, 2, 3];\n * // since the variance of a set is the mean squared\n * // deviations, we can calculate that with sumNthPowerDeviations:\n * var variance = sumNthPowerDeviations(input) / input.length;\n */\nfunction sumNthPowerDeviations(x, n) {\n    var meanValue = mean(x),\n        sum = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        sum += Math.pow(x[i] - meanValue, n);\n    }\n\n    return sum;\n}\n\nmodule.exports = sumNthPowerDeviations;\n\n},{\"./mean\":22}],48:[function(require,module,exports){\n'use strict';\n\nvar standardDeviation = require('./standard_deviation');\nvar mean = require('./mean');\n\n/**\n * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean\n * of a sample to a known value, x.\n *\n * in this case, we're trying to determine whether the\n * population mean is equal to the value that we know, which is `x`\n * here. usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * @param {Array<number>} sample an array of numbers as input\n * @param {number} x expected vale of the population mean\n * @returns {number} value\n * @example\n * tTest([1, 2, 3, 4, 5, 6], 3.385); //= 0.16494154\n */\nfunction tTest(sample, x) {\n    // The mean of the sample\n    var sampleMean = mean(sample);\n\n    // The standard deviation of the sample\n    var sd = standardDeviation(sample);\n\n    // Square root the length of the sample\n    var rootN = Math.sqrt(sample.length);\n\n    // Compute the known value against the sample,\n    // returning the t value\n    return (sampleMean - x) / (sd / rootN);\n}\n\nmodule.exports = tTest;\n\n},{\"./mean\":22,\"./standard_deviation\":44}],49:[function(require,module,exports){\n'use strict';\n\nvar mean = require('./mean');\nvar sampleVariance = require('./sample_variance');\n\n/**\n * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).\n * Tests whether \"mean(X)-mean(Y) = difference\", (\n * in the most common case, we often have `difference == 0` to test if two samples\n * are likely to be taken from populations with the same mean value) with\n * no prior knowledge on standard deviations of both samples\n * other than the fact that they have the same standard deviation.\n *\n * Usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * `diff` can be omitted if it equals 0.\n *\n * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)\n * a null hypothesis that the two populations that have been sampled into\n * `sampleX` and `sampleY` are equal to each other.\n *\n * @param {Array<number>} sampleX a sample as an array of numbers\n * @param {Array<number>} sampleY a sample as an array of numbers\n * @param {number} [difference=0]\n * @returns {number} test result\n * @example\n * ss.tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); //= -2.1908902300206643\n */\nfunction tTestTwoSample(sampleX, sampleY, difference) {\n    var n = sampleX.length,\n        m = sampleY.length;\n\n    // If either sample doesn't actually have any values, we can't\n    // compute this at all, so we return `null`.\n    if (!n || !m) { return null; }\n\n    // default difference (mu) is zero\n    if (!difference) {\n        difference = 0;\n    }\n\n    var meanX = mean(sampleX),\n        meanY = mean(sampleY);\n\n    var weightedVariance = ((n - 1) * sampleVariance(sampleX) +\n        (m - 1) * sampleVariance(sampleY)) / (n + m - 2);\n\n    return (meanX - meanY - difference) /\n        Math.sqrt(weightedVariance * (1 / n + 1 / m));\n}\n\nmodule.exports = tTestTwoSample;\n\n},{\"./mean\":22,\"./sample_variance\":40}],50:[function(require,module,exports){\n'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\n\n/**\n * The [variance](http://en.wikipedia.org/wiki/Variance)\n * is the sum of squared deviations from the mean.\n *\n * This is an implementation of variance, not sample variance:\n * see the `sampleVariance` method if you want a sample measure.\n *\n * @param {Array<number>} x a population\n * @returns {number} variance: a value greater than or equal to zero.\n * zero indicates that all values are identical.\n * @example\n * ss.variance([1, 2, 3, 4, 5, 6]); //= 2.917\n */\nfunction variance(x) {\n    // The variance of no numbers is null\n    if (x.length === 0) { return null; }\n\n    // Find the mean of squared deviations between the\n    // mean value and each value.\n    return sumNthPowerDeviations(x, 2) / x.length;\n}\n\nmodule.exports = variance;\n\n},{\"./sum_nth_power_deviations\":47}],51:[function(require,module,exports){\n'use strict';\n\n/**\n * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).\n *\n * The standard score is the number of standard deviations an observation\n * or datum is above or below the mean. Thus, a positive standard score\n * represents a datum above the mean, while a negative standard score\n * represents a datum below the mean. It is a dimensionless quantity\n * obtained by subtracting the population mean from an individual raw\n * score and then dividing the difference by the population standard\n * deviation.\n *\n * The z-score is only defined if one knows the population parameters;\n * if one only has a sample set, then the analogous computation with\n * sample mean and sample standard deviation yields the\n * Student's t-statistic.\n *\n * @param {number} x\n * @param {number} mean\n * @param {number} standardDeviation\n * @return {number} z score\n * @example\n * ss.zScore(78, 80, 5); //= -0.4\n */\nfunction zScore(x, mean, standardDeviation) {\n    return (x - mean) / standardDeviation;\n}\n\nmodule.exports = zScore;\n\n},{}],52:[function(require,module,exports){\n'use strict';\n\n/* global d3 */\n\n/**\n * A reusable d3 parallel coordinates generator with statistical coloring\n * @name parallelCoordinates\n * @module parallel coordinates\n * @author Taylor Denouden\n * @param {string} parent | {DOM element} parent - A dom element to append the vis to\n * @return {object} parallelCoordinates\n */\nmodule.exports = function parallelCoordinates(parent) {\n  var _y = {};\n  var _dragging = {};\n  var _line = d3.svg.line();\n  var _axis = d3.svg.axis().orient('left');\n  var _color = d3.scale.linear().domain([-2, -0.5, 0.5, 2]).range(['#f46d43', '#74add1', '#74add1', '#66bd63']).interpolate(d3.interpolateLab);\n  var _width = undefined;\n  var _height = undefined;\n  var _margin = undefined;\n  var _svg = undefined;\n  var _x = undefined;\n  var _background = undefined;\n  var _foreground = undefined;\n  var _dimensions = undefined;\n  var _data = undefined;\n  var _lineData = undefined;\n\n  /**\n   * Get the x axis position for some dimension and initialize dragging\n   * @private\n   * @param {string} d - The dimension name\n   * @return {float} - The distance to the right of the origin\n   */\n  function position(d) {\n    var v = _dragging[d];\n    return v ? v : _x(d);\n  }\n\n  /**\n   * Generate the line path for a datum.\n   * @private\n   * @param {object} d - An object with axis attributes\n   * @return {string} - SVG path text\n   */\n  function path(d) {\n    return _line(_dimensions.map(function (p) {\n      return [position(p), _y[p](d[p])];\n    }));\n  }\n\n  /**\n   * Map a list of objects where each object is an attribute with line values to\n   *     a list of objects where each object is a line with its attributes listed\n   * @private\n   * @param {list} data - A list of objects\n   *      eg {\n   *        name: Area,\n   *        data: [14234, 34132],\n   *        scale : d3.scale.linear()\n   *      }\n   *\n   * @return {list} - A list of line objects\n   *      eg {\n   *        Area: 14234\n   *        Bird species: 67\n   *        Distance to Mainland: 14165.85749\n   *        Land within 500m: 2.60546\n   *      }\n   */\n  function dataToLines(data) {\n    var result = [];\n    data[0].data.forEach(function (d, i) {\n      return result[i] = {};\n    });\n    data.forEach(function forEachDim(dim) {\n      result.forEach(function addDimData(line, i) {\n        result[i][dim.name] = dim.data[i];\n      });\n    });\n    return result;\n  }\n\n  /**\n   * color by zScore\n   * @private\n   * @param {list} col - A list of values to generate a z-score function from\n   * @return {object} - Function that returns z-score relative to values in col\n   */\n  function zScore(col) {\n    var mean = d3.mean(col);\n    var sigma = d3.deviation(col);\n    // Return zScore if std_dev is not 0, else 0\n    return function (d) {\n      return sigma ? (d - mean) / sigma : 0;\n    };\n  }\n\n  /**\n   * Change foreground line color\n   * @private\n   * @param {string} dimension - The name of the dimension to change\n   * @returns {void}\n   */\n  function changeColor(dimension) {\n    _svg.selectAll('.dimension').style('font-weight', 'normal').classed('z-scored', false).filter(function (d) {\n      return d === dimension;\n    }).style('font-weight', 'bold').classed('z-scored', true);\n    var z = zScore(_lineData.map(function (i) {\n      return parseFloat(i[dimension]);\n    }));\n\n    // lines\n    _svg.select('.foreground').selectAll('path').style('stroke', function (d) {\n      return _color(z(d[dimension]));\n    });\n  }\n\n  /**\n   * Provide a consisten transition length\n   * @private\n   * @param {object} g - An d3 selection that can be transitioned\n   * @return {object} - A d3 transition object\n   */\n  function transition(g) {\n    return g.transition().duration(500);\n  }\n\n  /**\n   * A brushstart callback control\n   * @private\n   * @returns {void}\n   */\n  function brushstart() {\n    d3.event.sourceEvent.stopPropagation();\n  }\n\n  /**\n   * Handles a brush event, toggling the display of foreground lines.\n   * @private\n   * @returns {void}\n   */\n  function brush() {\n    var actives = _dimensions.filter(function (p) {\n      return !_y[p].brush.empty();\n    });\n    var extents = actives.map(function (p) {\n      return _y[p].brush.extent();\n    });\n    _foreground.style('display', function toggleDisplay(d) {\n      return actives.every(function brushed(p, i) {\n        var x = Math.round(d[p] * 100) / 100;\n        return Math.round(extents[i][0] * 100) / 100 <= x && x <= Math.round(extents[i][1] * 100) / 100;\n      }) ? null : 'none';\n    });\n  }\n\n  /**\n   * Generate the chart using private variables on call to chart.render()\n   * @private\n   * @returns {parallelCoordinates}\n   */\n  function _chart() {\n    _svg = d3.select(parent).append('svg').attr('width', _width + _margin.left + _margin.right).attr('height', _height + _margin.top + _margin.bottom).append('g').attr('transform', 'translate(' + _margin.left + ',' + _margin.top + ')');\n\n    // Create a scale for each dimension\n    _data.forEach(function initScale(d) {\n      _y[d.name] = (d.scale || d3.scale.linear()).domain(d3.extent(d.data)).range([_height, 0]);\n    });\n\n    // Extract the list of _dimensions\n    _dimensions = _data.map(function (d) {\n      return d.name;\n    });\n    _x = d3.scale.ordinal().domain(_dimensions).rangePoints([0, _width], 1);\n\n    // Add grey background lines for context.\n    _background = _svg.append('g').attr('class', 'background').selectAll('path').data(_lineData).enter().append('path').attr('d', path);\n\n    // Add blue foreground lines for focus.\n    _foreground = _svg.append('g').attr('class', 'foreground').selectAll('path').data(_lineData).enter().append('path').attr('d', path);\n\n    // Add a group element for each dimension.\n    var g = _svg.selectAll('.dimension').data(_dimensions).enter().append('g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + _x(d) + ')';\n    }).call(d3.behavior.drag().origin(function (d) {\n      return { x: _x(d) };\n    }).on('dragstart', function onDragStart(d) {\n      _dragging[d] = _x(d);\n      _background.attr('visibility', 'hidden');\n    }).on('drag', function onDrag(d) {\n      _dragging[d] = Math.min(_width, Math.max(0, d3.event.x));\n      _foreground.attr('d', path);\n      _dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n      _x.domain(_dimensions);\n      g.attr('transform', function (b) {\n        return 'translate(' + position(b) + ')';\n      });\n    }).on('dragend', function onDragEnd(d) {\n      delete _dragging[d];\n      transition(d3.select(this)).attr('transform', 'translate(' + _x(d) + ')');\n      transition(_foreground).attr('d', path);\n      _background.attr('d', path).transition().delay(500).duration(0).attr('visibility', null);\n    }));\n\n    // Add an axis and title.\n    g.append('g').attr('class', 'axis').each(function callAxis(d) {\n      d3.select(this).call(_axis.scale(_y[d]));\n    }).on('click', changeColor).append('text').style('text-anchor', 'middle').attr('y', -9).text(function (d) {\n      return d;\n    });\n\n    // Add and store a brush for each axis.\n    g.append('g').attr('class', 'brush').each(function storeBrush(d) {\n      d3.select(this).call(_y[d].brush = d3.svg.brush().y(_y[d]).on('brushstart', brushstart).on('brush', brush));\n    }).selectAll('rect').attr('x', -8).attr('width', 16);\n\n    // Color _dimensions by z-score\n    changeColor(_dimensions[0]);\n  }\n\n  /**\n   * @name render\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.render = function render() {\n    this.call();\n    return _chart;\n  };\n\n  /**\n   * @name redraw\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.redraw = function redraw() {\n    //  Fade out and remove lines\n    transition(_background).style('opacity', 0).transition().remove();\n    transition(_foreground).style('opacity', 0).transition().remove();\n\n    // Adjust axes domains\n    _data.forEach(function adjustAxisDomain(d) {\n      var extent = d3.extent(d.data);\n      if (extent[0] === extent[1]) {\n        extent[0] -= extent[0] / 2;\n        extent[1] += extent[1] / 2;\n      }\n      _y[d.name].domain(extent);\n    });\n\n    // Transition axes\n    _svg.selectAll('.axis').each(function transitionAxis(d) {\n      transition(d3.select(this)).delay(500).call(_axis.scale(_y[d]));\n    });\n\n    // Rebind data\n    _background = _svg.select('.background').selectAll('path').data(_lineData);\n    _foreground = _svg.select('.foreground').selectAll('path').data(_lineData);\n    // Update\n    _background.style('opacity', 0).attr('d', path);\n    _foreground.style('opacity', 0).attr('d', path);\n\n    // Enter\n    _background.enter().append('path').style('opacity', 0).attr('d', path);\n    _foreground.enter().append('path').style('opacity', 0).attr('d', path);\n\n    // Update color\n    changeColor(d3.select('.z-scored').data()[0]);\n\n    // Fade in lines\n    transition(_background).delay(1000).style('opacity', 0.5);\n    transition(_foreground).delay(1000).style('opacity', 0.5);\n\n    return _chart;\n  };\n\n  /**\n   * @name width\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.width = function width(val) {\n    if (!arguments.length) {\n      return _width;\n    }\n    _width = val;\n    return _chart;\n  };\n\n  /**\n   * @name height\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.height = function height(val) {\n    if (!arguments.length) {\n      return _height;\n    }\n    _height = val;\n    return _chart;\n  };\n\n  /**\n   * @name margin\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.margin = function margin(val) {\n    if (!arguments.length) {\n      return _margin;\n    }\n    _margin = val;\n    return _chart;\n  };\n\n  /**\n   * @name width\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.data = function data(val) {\n    if (!arguments.length) {\n      return _data;\n    }\n    _data = val;\n    _lineData = dataToLines(_data);\n    return _chart;\n  };\n\n  return _chart;\n};\n\n},{}],53:[function(require,module,exports){\n'use strict';\n\n/* global d3 */\n\n// Include and bundle simple statistics\nvar ss = require('simple-statistics');\n\n/**\n * A reusable d3 scatterplot generator\n * @name scatterplot\n * @module scatterplot\n * @author Taylor Denouden\n * @param {string} parent | {DOM element} parent - A dom element to append the vis to\n * @return {object} scatterplot chart\n */\nmodule.exports = function scatterplot(parent) {\n  var _width = undefined;\n  var _height = undefined;\n  var _margin = undefined;\n  var _data = undefined;\n  var _x = d3.scale.linear();\n  var _y = d3.scale.linear();\n  var _xLog = false;\n  var _yLog = false;\n  var _xAxis = undefined;\n  var _yAxis = undefined;\n  var _xAccessor = undefined;\n  var _yAccessor = undefined;\n  var _xLabel = undefined;\n  var _yLabel = undefined;\n  var _color = d3.scale.category10();\n  var _colorAccessor = function _colorAccessor() {\n    return 0;\n  };\n  var _keyAccessor = function _keyAccessor(d) {\n    return d.key;\n  };\n  var _radius = 5;\n  var _regLine = undefined;\n  var _rSquared = 1;\n  var _correlation = 1;\n  var _covariance = 1;\n  var _svg = undefined;\n\n  /**\n   * Return the base ten log of a Number\n   * @private\n   * @param {number} d - A number to apply the operation on\n   * @return {number} log base 10 of d\n   */\n  function log10(d) {\n    return Math.log(d) / Math.log(10);\n  }\n\n  /**\n   * Given an x value of un-transformed data (no log transform etc.),\n   * get the untransformed y coordinate from the regression line\n   * @private\n   * @param {number} x - The untransformed x value in linear space\n   * @param {function} regLine - The regression line calculated using\n   *    a transformed dataset that accounted for the log scales\n   * @return {number} y - The untransformed y value in linear space to plot on the chart\n   */\n  function getY(x, regLine) {\n    var y = regLine(_xLog ? log10(x) : x);\n    return _yLog ? Math.pow(10, y) : y;\n  }\n\n  /**\n   * Calculate all chart statistical values and regresslion linearRegression\n   * @private\n   * @param {Object[]} data - The dataset used to calculate the statistics\n   * @return {Object} stats - An object with all calculated statistics\n   */\n  function calculateStats(data) {\n    // Get regression line formula\n    var ssData = data.map(function ssData(d) {\n      var xD = _xLog ? log10(_xAccessor(d)) : _xAccessor(d);\n      var yD = _yLog ? log10(_yAccessor(d)) : _yAccessor(d);\n      return [xD, yD];\n    });\n    var mb = ss.linearRegression(ssData);\n    var regLine = ss.linearRegressionLine(mb);\n\n    // Calculated statistics\n    var rSquared = ss.rSquared(ssData, regLine);\n    var correlation = ss.sampleCorrelation(ssData.map(function (d) {\n      return d[0];\n    }), ssData.map(function (d) {\n      return d[1];\n    }));\n    var covariance = ss.sampleCovariance(ssData.map(function (d) {\n      return d[0];\n    }), ssData.map(function (d) {\n      return d[1];\n    }));\n\n    return {\n      reg: mb,\n      regLine: regLine,\n      rSquared: rSquared,\n      correlation: correlation,\n      covariance: covariance\n    };\n  }\n\n  /**\n   * Generate the chart using private variables on call to chart.render()\n   * @private\n   * @returns {scatterplot}\n   */\n  function _chart() {\n    // Create svg object\n    _svg = d3.select(parent).append('svg').attr('width', _width + _margin.left + _margin.right).attr('height', _height + _margin.top + _margin.bottom).append('g').attr('transform', 'translate(' + _margin.left + ',' + _margin.top + ')');\n\n    // Create cleaned dataset that doesn't include non numeric or log(0) values\n    var cleanData = _data.filter(function (d) {\n      return !(isNaN(_xAccessor(d)) || isNaN(_yAccessor(d)));\n    }).filter(function (d) {\n      return !(_xLog && _xAccessor(d) === 0 || _yLog && _yAccessor(d) === 0);\n    });\n\n    // Set x and y axis based on selected attributes\n    _x.domain(d3.extent(cleanData, _xAccessor)).range([0, _width]);\n    _y.domain(d3.extent(cleanData, _yAccessor)).range([_height, 0]);\n\n    // Create svg axis generators\n    _xAxis = d3.svg.axis().scale(_x).orient('bottom').tickSize(-_height);\n    _yAxis = d3.svg.axis().scale(_y).orient('left').tickSize(-_width);\n\n    // Add axes to chart\n    _svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0, ' + _height + ')').call(_xAxis);\n    _svg.append('g').attr('class', 'y axis').call(_yAxis);\n\n    // Add axis labels\n    _svg.append('text').attr('class', 'x label').attr('text-anchor', 'end').attr('x', _width - 10).attr('y', _height - 5).text(_xLabel);\n    _svg.append('text').attr('class', 'y label').attr('transform', 'rotate(-90)').attr('text-anchor', 'end').attr('x', -5).attr('y', 10).text(_yLabel);\n\n    // Add frame around chart\n    _svg.append('rect').attr('class', 'frame').attr('width', _width).attr('height', _height);\n\n    // Create clip path\n    _svg.append('defs').append('clipPath').attr('id', 'chartClip').append('rect').attr('width', _width).attr('height', _height);\n\n    // Calculate statistics and regression line\n    var stats = calculateStats(cleanData);\n    _regLine = stats.regLine;\n    _rSquared = stats.rSquared;\n    _correlation = stats.correlation;\n    _covariance = stats.covariance;\n\n    // Add regression line to Chart\n    _svg.append('g').attr('class', 'regression').attr('clip-path', 'url(#chartClip)').append('line').style('stroke', 'black').style('stroke-width', '1').style('stroke-dasharray', '5,5,10,5').attr('x1', _x(_x.domain()[0])).attr('y1', _y(getY(_x.domain()[0], _regLine))).attr('x2', _x(_x.domain()[1])).attr('y2', _y(getY(_x.domain()[1], _regLine)));\n\n    // Add data marks to chart\n    var marks = _svg.selectAll('g.mark').data(cleanData).enter().append('g').attr('class', 'mark');\n\n    marks.append('circle').attr('cx', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('cy', function (d) {\n      return _y(_yAccessor(d));\n    }).attr('r', _radius).attr('fill', function (d) {\n      return _color(_colorAccessor(d));\n    });\n\n    marks.append('text').text(_keyAccessor).attr('x', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('y', function (d) {\n      return _y(_yAccessor(d));\n    }).attr('text-anchor', 'end').attr('dy', -5).attr('dx', -2);\n  }\n\n  /**\n   * Draw the chart after parameters have been set.\n   * @name render\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.render = function render() {\n    this.call();\n    return _chart;\n  };\n\n  /**\n   * Redraw and transform the chart after parameter changes.\n   * @name redraw\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.redraw = function redraw() {\n    // Create cleaned dataset that doesn't include non numeric or log(0) values\n    var cleanData = _data.filter(function (d) {\n      return !(isNaN(_xAccessor(d)) || isNaN(_yAccessor(d)));\n    }).filter(function (d) {\n      return !(_xLog && _xAccessor(d) === 0 || _yLog && _yAccessor(d) === 0);\n    });\n\n    // Update x and y domain\n    _x.domain(d3.extent(cleanData, _xAccessor)).range([0, _width]);\n    _y.domain(d3.extent(cleanData, _yAccessor)).range([_height, 0]);\n\n    // Update axes generator scale\n    _xAxis.scale(_x);\n    _yAxis.scale(_y);\n\n    // Define consistent transition duration\n    var t = 1500;\n\n    // Update axes\n    _svg.select('.x.axis').transition().duration(t).call(_xAxis);\n    _svg.select('.y.axis').transition().duration(t).call(_yAxis);\n\n    // Update axis labels\n    _svg.select('.x.label').text(_xLabel);\n    _svg.select('.y.label').text(_yLabel);\n\n    // Calculate statistics and regression line\n    var stats = calculateStats(cleanData);\n    _regLine = stats.regLine;\n    _rSquared = stats.rSquared;\n    _correlation = stats.correlation;\n    _covariance = stats.covariance;\n\n    // Add regression line to Chart\n    _svg.select('.regression line').transition().duration(t).attr('x1', _x(_x.domain()[0])).attr('y1', _y(getY(_x.domain()[0], _regLine))).attr('x2', _x(_x.domain()[1])).attr('y2', _y(getY(_x.domain()[1], _regLine)));\n\n    // Update data and mark positions\n    var marks = _svg.selectAll('g.mark').data(cleanData, _keyAccessor);\n\n    // Update\n    marks.selectAll('circle').transition().duration(t).attr('cx', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('cy', function (d) {\n      return _y(_yAccessor(d));\n    }).attr('r', _radius).attr('fill', function (d) {\n      return _color(_colorAccessor(d));\n    });\n\n    marks.selectAll('text').transition().duration(t).attr('x', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('y', function (d) {\n      return _y(_yAccessor(d));\n    });\n\n    // Enter\n    var g = marks.enter().append('g').attr('class', 'mark');\n\n    g.append('circle').attr('cx', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('cy', function (d) {\n      return _y(_yAccessor(d));\n    }).attr('r', _radius).attr('fill', function (d) {\n      return _color(_colorAccessor(d));\n    });\n\n    g.append('text').text(_keyAccessor).attr('x', function (d) {\n      return _x(_xAccessor(d));\n    }).attr('y', function (d) {\n      return _y(_yAccessor(d));\n    }).attr('text-anchor', 'end').attr('dy', -5).attr('dx', -2);\n\n    // Exit\n    marks.exit().remove();\n\n    return _chart;\n  };\n\n  /**\n   * Set or get the width attribute of a chart.\n   * @name width\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.width = function width(val) {\n    if (!arguments.length) {\n      return _width;\n    }\n    _width = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the height attribute of a chart.\n   * @name height\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.height = function height(val) {\n    if (!arguments.length) {\n      return _height;\n    }\n    _height = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the margin attribute of a chart.\n   * @name margin\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.margin = function margin(val) {\n    if (!arguments.length) {\n      return _margin;\n    }\n    _margin = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the data that accessor functions refer to.\n   * @name data\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.data = function data(val) {\n    if (!arguments.length) {\n      return _data;\n    }\n    _data = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data shown on the x axis.\n   * @name xAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xAccessor = function xAccessor(val) {\n    if (!arguments.length) {\n      return _xAccessor;\n    }\n    _xAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data shown on the y axis.\n   * @name yAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yAccessor = function yAccessor(val) {\n    if (!arguments.length) {\n      return _yAccessor;\n    }\n    _yAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the x axis label.\n   * @name xLabel\n   * @instance\n   * @param {String} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xLabel = function xLabel(val) {\n    if (!arguments.length) {\n      return _xLabel;\n    }\n    _xLabel = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the y axis label.\n   * @name yLabel\n   * @instance\n   * @param {String} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yLabel = function yLabel(val) {\n    if (!arguments.length) {\n      return _yLabel;\n    }\n    _yLabel = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get whether the x axis scale should be log transformed.\n   * @name xLog\n   * @instance\n   * @param {Boolean} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xLog = function xLog(val) {\n    if (!arguments.length) {\n      return _xLog;\n    }\n    _xLog = val;\n    _x = _xLog ? d3.scale.log() : d3.scale.linear();\n    return _chart;\n  };\n\n  /**\n   * Set or get whether the y axis scale should be log transformed.\n   * @name yLog\n   * @instance\n   * @param {Boolean} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yLog = function yLog(val) {\n    if (!arguments.length) {\n      return _yLog;\n    }\n    _yLog = val;\n    _y = _yLog ? d3.scale.log() : d3.scale.linear();\n    return _chart;\n  };\n\n  /**\n   * Set or get a scale function that accepts a data value and returns a color.\n   * @name color\n   * @instance\n   * @param {Function} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.color = function color(val) {\n    if (!arguments.length) {\n      return _color;\n    }\n    _color = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data and pass the value to the color function.\n   * @name colorAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.colorAccessor = function colorAccessor(val) {\n    if (!arguments.length) {\n      return _colorAccessor;\n    }\n    _colorAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to determine which points shown are the same datum.\n   * Allows for mark translation on redraw.\n   * @name keyAccessor\n   * @instance\n   * @param {Function} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.keyAccessor = function keyAccessor(val) {\n    if (!arguments.length) {\n      return _keyAccessor;\n    }\n    _keyAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a radius value or a scale function that accepts a\n   * data value and returns a radius size.\n   * @name radius\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.radius = function radius(val) {\n    if (!arguments.length) {\n      return _radius;\n    }\n    _radius = val;\n    return _chart;\n  };\n\n  /**\n   * Return the R squared value determined by the linear regression function.\n   * @name rSquare\n   * @instance\n   * @return {float}\n   */\n  _chart.rSquared = function rSquared() {\n    return _rSquared;\n  };\n\n  /**\n   * Return the correlation value determined by the linear regression function.\n   * @name correlation\n   * @instance\n   * @return {float}\n   */\n  _chart.correlation = function correlation() {\n    return _correlation;\n  };\n\n  /**\n   * Return the covariance value determined by the linear regression function.\n   * @name covariance\n   * @instance\n   * @return {float}\n   */\n  _chart.covariance = function covariance() {\n    return _covariance;\n  };\n\n  return _chart;\n};\n\n},{\"simple-statistics\":2}]},{},[1])\n\n","module.exports = {\n  parallelCoordinates: require('./src/js/parallel_coordinates'),\n  scatterplot: require('./src/js/scatterplot'),\n};\n","'use strict';\n\n// # simple-statistics\n//\n// A simple, literate statistics system.\n\nvar ss = module.exports = {};\n\n// Linear Regression\nss.linearRegression = require('./src/linear_regression');\nss.linearRegressionLine = require('./src/linear_regression_line');\nss.standardDeviation = require('./src/standard_deviation');\nss.rSquared = require('./src/r_squared');\nss.mode = require('./src/mode');\nss.min = require('./src/min');\nss.max = require('./src/max');\nss.sum = require('./src/sum');\nss.quantile = require('./src/quantile');\nss.quantileSorted = require('./src/quantile_sorted');\nss.iqr = ss.interquartileRange = require('./src/interquartile_range');\nss.medianAbsoluteDeviation = ss.mad = require('./src/mad');\nss.chunk = require('./src/chunk');\nss.shuffle = require('./src/shuffle');\nss.shuffleInPlace = require('./src/shuffle_in_place');\nss.sample = require('./src/sample');\nss.ckmeans = require('./src/ckmeans');\nss.sortedUniqueCount = require('./src/sorted_unique_count');\nss.sumNthPowerDeviations = require('./src/sum_nth_power_deviations');\n\n// sample statistics\nss.sampleCovariance = require('./src/sample_covariance');\nss.sampleCorrelation = require('./src/sample_correlation');\nss.sampleVariance = require('./src/sample_variance');\nss.sampleStandardDeviation = require('./src/sample_standard_deviation');\nss.sampleSkewness = require('./src/sample_skewness');\n\n// measures of centrality\nss.geometricMean = require('./src/geometric_mean');\nss.harmonicMean = require('./src/harmonic_mean');\nss.mean = ss.average = require('./src/mean');\nss.median = require('./src/median');\n\nss.rootMeanSquare = ss.rms = require('./src/root_mean_square');\nss.variance = require('./src/variance');\nss.tTest = require('./src/t_test');\nss.tTestTwoSample = require('./src/t_test_two_sample');\n// ss.jenks = require('./src/jenks');\n\n// Classifiers\nss.bayesian = require('./src/bayesian_classifier');\nss.perceptron = require('./src/perceptron');\n\n// Distribution-related methods\nss.epsilon = require('./src/epsilon'); // We make ε available to the test suite.\nss.factorial = require('./src/factorial');\nss.bernoulliDistribution = require('./src/bernoulli_distribution');\nss.binomialDistribution = require('./src/binomial_distribution');\nss.poissonDistribution = require('./src/poisson_distribution');\nss.chiSquaredGoodnessOfFit = require('./src/chi_squared_goodness_of_fit');\n\n// Normal distribution\nss.zScore = require('./src/z_score');\nss.cumulativeStdNormalProbability = require('./src/cumulative_std_normal_probability');\nss.standardNormalTable = require('./src/standard_normal_table');\nss.errorFunction = ss.erf = require('./src/error_function');\nss.inverseErrorFunction = require('./src/inverse_error_function');\nss.probit = require('./src/probit');\nss.mixin = require('./src/mixin');\n","'use strict';\n\n/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nfunction BayesianClassifier() {\n    // The number of items that are currently\n    // classified in the model\n    this.totalCount = 0;\n    // Every item classified in the model\n    this.data = {};\n}\n\n/**\n * Train the classifier with a new item, which has a single\n * dimension of Javascript literal keys and values.\n *\n * @param {Object} item an object with singly-deep properties\n * @param {string} category the category this item belongs to\n * @return {undefined} adds the item to the classifier\n */\nBayesianClassifier.prototype.train = function(item, category) {\n    // If the data object doesn't have any values\n    // for this category, create a new object for it.\n    if (!this.data[category]) {\n        this.data[category] = {};\n    }\n\n    // Iterate through each key in the item.\n    for (var k in item) {\n        var v = item[k];\n        // Initialize the nested object `data[category][k][item[k]]`\n        // with an object of keys that equal 0.\n        if (this.data[category][k] === undefined) {\n            this.data[category][k] = {};\n        }\n        if (this.data[category][k][v] === undefined) {\n            this.data[category][k][v] = 0;\n        }\n\n        // And increment the key for this key/value combination.\n        this.data[category][k][item[k]]++;\n    }\n\n    // Increment the number of items classified\n    this.totalCount++;\n};\n\n/**\n * Generate a score of how well this item matches all\n * possible categories based on its attributes\n *\n * @param {Object} item an item in the same format as with train\n * @returns {Object} of probabilities that this item belongs to a\n * given category.\n */\nBayesianClassifier.prototype.score = function(item) {\n    // Initialize an empty array of odds per category.\n    var odds = {}, category;\n    // Iterate through each key in the item,\n    // then iterate through each category that has been used\n    // in previous calls to `.train()`\n    for (var k in item) {\n        var v = item[k];\n        for (category in this.data) {\n            // Create an empty object for storing key - value combinations\n            // for this category.\n            if (odds[category] === undefined) { odds[category] = {}; }\n\n            // If this item doesn't even have a property, it counts for nothing,\n            // but if it does have the property that we're looking for from\n            // the item to categorize, it counts based on how popular it is\n            // versus the whole population.\n            if (this.data[category][k]) {\n                odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount;\n            } else {\n                odds[category][k + '_' + v] = 0;\n            }\n        }\n    }\n\n    // Set up a new object that will contain sums of these odds by category\n    var oddsSums = {};\n\n    for (category in odds) {\n        // Tally all of the odds for each category-combination pair -\n        // the non-existence of a category does not add anything to the\n        // score.\n        for (var combination in odds[category]) {\n            if (oddsSums[category] === undefined) {\n                oddsSums[category] = 0;\n            }\n            oddsSums[category] += odds[category][combination];\n        }\n    }\n\n    return oddsSums;\n};\n\nmodule.exports = BayesianClassifier;\n","'use strict';\n\nvar binomialDistribution = require('./binomial_distribution');\n\n/**\n * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)\n * is the probability discrete\n * distribution of a random variable which takes value 1 with success\n * probability `p` and value 0 with failure\n * probability `q` = 1 - `p`. It can be used, for example, to represent the\n * toss of a coin, where \"1\" is defined to mean \"heads\" and \"0\" is defined\n * to mean \"tails\" (or vice versa). It is\n * a special case of a Binomial Distribution\n * where `n` = 1.\n *\n * @param {number} p input value, between 0 and 1 inclusive\n * @returns {number} value of bernoulli distribution at this point\n */\nfunction bernoulliDistribution(p) {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1)\n    if (p < 0 || p > 1 ) { return null; }\n\n    return binomialDistribution(1, p);\n}\n\nmodule.exports = bernoulliDistribution;\n","'use strict';\n\nvar epsilon = require('./epsilon');\nvar factorial = require('./factorial');\n\n/**\n * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability\n * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields\n * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or\n * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.\n *\n * @param {number} trials number of trials to simulate\n * @param {number} probability\n * @returns {number} output\n */\nfunction binomialDistribution(trials, probability) {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1),\n    // that `n` is an integer, strictly positive.\n    if (probability < 0 || probability > 1 ||\n        trials <= 0 || trials % 1 !== 0) {\n        return null;\n    }\n\n    // We initialize `x`, the random variable, and `accumulator`, an accumulator\n    // for the cumulative distribution function to 0. `distribution_functions`\n    // is the object we'll return with the `probability_of_x` and the\n    // `cumulativeProbability_of_x`, as well as the calculated mean &\n    // variance. We iterate until the `cumulativeProbability_of_x` is\n    // within `epsilon` of 1.0.\n    var x = 0,\n        cumulativeProbability = 0,\n        cells = {};\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = factorial(trials) /\n            (factorial(x) * factorial(trials - x)) *\n            (Math.pow(probability, x) * Math.pow(1 - probability, trials - x));\n        cumulativeProbability += cells[x];\n        x++;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = binomialDistribution;\n","'use strict';\n\n/**\n * **Percentage Points of the χ2 (Chi-Squared) Distribution**\n *\n * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common\n * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two\n * criteria of classification of qualitative data, and in confidence interval estimation for a population standard\n * deviation of a normal distribution from a sample standard deviation.\n *\n * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, \"Probability and Statistics in\n * Engineering and Management Science\", Wiley (1980).\n */\nvar chiSquaredDistributionTable = {\n    1: { 0.995:  0.00, 0.99:  0.00, 0.975:  0.00, 0.95:  0.00, 0.9:  0.02, 0.5:  0.45, 0.1:  2.71, 0.05:  3.84, 0.025:  5.02, 0.01:  6.63, 0.005:  7.88 },\n    2: { 0.995:  0.01, 0.99:  0.02, 0.975:  0.05, 0.95:  0.10, 0.9:  0.21, 0.5:  1.39, 0.1:  4.61, 0.05:  5.99, 0.025:  7.38, 0.01:  9.21, 0.005: 10.60 },\n    3: { 0.995:  0.07, 0.99:  0.11, 0.975:  0.22, 0.95:  0.35, 0.9:  0.58, 0.5:  2.37, 0.1:  6.25, 0.05:  7.81, 0.025:  9.35, 0.01: 11.34, 0.005: 12.84 },\n    4: { 0.995:  0.21, 0.99:  0.30, 0.975:  0.48, 0.95:  0.71, 0.9:  1.06, 0.5:  3.36, 0.1:  7.78, 0.05:  9.49, 0.025: 11.14, 0.01: 13.28, 0.005: 14.86 },\n    5: { 0.995:  0.41, 0.99:  0.55, 0.975:  0.83, 0.95:  1.15, 0.9:  1.61, 0.5:  4.35, 0.1:  9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 0.005: 16.75 },\n    6: { 0.995:  0.68, 0.99:  0.87, 0.975:  1.24, 0.95:  1.64, 0.9:  2.20, 0.5:  5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 0.005: 18.55 },\n    7: { 0.995:  0.99, 0.99:  1.25, 0.975:  1.69, 0.95:  2.17, 0.9:  2.83, 0.5:  6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 0.005: 20.28 },\n    8: { 0.995:  1.34, 0.99:  1.65, 0.975:  2.18, 0.95:  2.73, 0.9:  3.49, 0.5:  7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 0.005: 21.96 },\n    9: { 0.995:  1.73, 0.99:  2.09, 0.975:  2.70, 0.95:  3.33, 0.9:  4.17, 0.5:  8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 0.005: 23.59 },\n    10: { 0.995:  2.16, 0.99:  2.56, 0.975:  3.25, 0.95:  3.94, 0.9:  4.87, 0.5:  9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 0.005: 25.19 },\n    11: { 0.995:  2.60, 0.99:  3.05, 0.975:  3.82, 0.95:  4.57, 0.9:  5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 0.005: 26.76 },\n    12: { 0.995:  3.07, 0.99:  3.57, 0.975:  4.40, 0.95:  5.23, 0.9:  6.30, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 0.005: 28.30 },\n    13: { 0.995:  3.57, 0.99:  4.11, 0.975:  5.01, 0.95:  5.89, 0.9:  7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 0.005: 29.82 },\n    14: { 0.995:  4.07, 0.99:  4.66, 0.975:  5.63, 0.95:  6.57, 0.9:  7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 0.005: 31.32 },\n    15: { 0.995:  4.60, 0.99:  5.23, 0.975:  6.27, 0.95:  7.26, 0.9:  8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25.00, 0.025: 27.49, 0.01: 30.58, 0.005: 32.80 },\n    16: { 0.995:  5.14, 0.99:  5.81, 0.975:  6.91, 0.95:  7.96, 0.9:  9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.30, 0.025: 28.85, 0.01: 32.00, 0.005: 34.27 },\n    17: { 0.995:  5.70, 0.99:  6.41, 0.975:  7.56, 0.95:  8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 0.005: 35.72 },\n    18: { 0.995:  6.26, 0.99:  7.01, 0.975:  8.23, 0.95:  9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 0.005: 37.16 },\n    19: { 0.995:  6.84, 0.99:  7.63, 0.975:  8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.20, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 0.005: 38.58 },\n    20: { 0.995:  7.43, 0.99:  8.26, 0.975:  9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 0.005: 40.00 },\n    21: { 0.995:  8.03, 0.99:  8.90, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 0.005: 41.40 },\n    22: { 0.995:  8.64, 0.99:  9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 0.005: 42.80 },\n    23: { 0.995:  9.26, 0.99: 10.20, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 0.005: 44.18 },\n    24: { 0.995:  9.89, 0.99: 10.86, 0.975: 12.40, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.20, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 0.005: 45.56 },\n    25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 0.005: 46.93 },\n    26: { 0.995: 11.16, 0.99: 12.20, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 0.005: 48.29 },\n    27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 0.005: 49.65 },\n    28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 0.005: 50.99 },\n    29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 0.005: 52.34 },\n    30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.60, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 0.005: 53.67 },\n    40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 0.005: 66.77 },\n    50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.50, 0.025: 71.42, 0.01: 76.15, 0.005: 79.49 },\n    60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.40, 0.05: 79.08, 0.025: 83.30, 0.01: 88.38, 0.005: 91.95 },\n    70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 0.005: 104.22 },\n    80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 0.005: 116.32 },\n    90: { 0.995: 59.20, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 0.005: 128.30 },\n    100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.50, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 0.005: 140.17 }\n};\n\nmodule.exports = chiSquaredDistributionTable;\n","'use strict';\n\nvar mean = require('./mean');\nvar chiSquaredDistributionTable = require('./chi_squared_distribution_table');\n\n/**\n * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)\n * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies\n * (that is, counts of observations), each squared and divided by the number of observations expected given the\n * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution\n * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one\n * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic\n * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty\n * cells and `c` is the number of estimated parameters for the distribution.\n *\n * @param {Array<number>} data\n * @param {Function} distributionType a function that returns a point in a distribution:\n * for instance, binomial, bernoulli, or poisson\n * @param {number} significance\n * @returns {number} chi squared goodness of fit\n * @example\n * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,\n * // \"Probability and Statistics in Engineering and Management Science\", Wiley (1980).\n * var data1019 = [\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n *     2, 2, 2, 2, 2, 2, 2, 2, 2,\n *     3, 3, 3, 3\n * ];\n * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05)); //= false\n */\nfunction chiSquaredGoodnessOfFit(data, distributionType, significance) {\n    // Estimate from the sample data, a weighted mean.\n    var inputMean = mean(data),\n        // Calculated value of the χ2 statistic.\n        chiSquared = 0,\n        // Degrees of freedom, calculated as (number of class intervals -\n        // number of hypothesized distribution parameters estimated - 1)\n        degreesOfFreedom,\n        // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.\n        // Lose one degree of freedom for estimating `lambda` from the sample data.\n        c = 1,\n        // The hypothesized distribution.\n        // Generate the hypothesized distribution.\n        hypothesizedDistribution = distributionType(inputMean),\n        observedFrequencies = [],\n        expectedFrequencies = [],\n        k;\n\n    // Create an array holding a histogram from the sample data, of\n    // the form `{ value: numberOfOcurrences }`\n    for (var i = 0; i < data.length; i++) {\n        if (observedFrequencies[data[i]] === undefined) {\n            observedFrequencies[data[i]] = 0;\n        }\n        observedFrequencies[data[i]]++;\n    }\n\n    // The histogram we created might be sparse - there might be gaps\n    // between values. So we iterate through the histogram, making\n    // sure that instead of undefined, gaps have 0 values.\n    for (i = 0; i < observedFrequencies.length; i++) {\n        if (observedFrequencies[i] === undefined) {\n            observedFrequencies[i] = 0;\n        }\n    }\n\n    // Create an array holding a histogram of expected data given the\n    // sample size and hypothesized distribution.\n    for (k in hypothesizedDistribution) {\n        if (k in observedFrequencies) {\n            expectedFrequencies[k] = hypothesizedDistribution[k] * data.length;\n        }\n    }\n\n    // Working backward through the expected frequencies, collapse classes\n    // if less than three observations are expected for a class.\n    // This transformation is applied to the observed frequencies as well.\n    for (k = expectedFrequencies.length - 1; k >= 0; k--) {\n        if (expectedFrequencies[k] < 3) {\n            expectedFrequencies[k - 1] += expectedFrequencies[k];\n            expectedFrequencies.pop();\n\n            observedFrequencies[k - 1] += observedFrequencies[k];\n            observedFrequencies.pop();\n        }\n    }\n\n    // Iterate through the squared differences between observed & expected\n    // frequencies, accumulating the `chiSquared` statistic.\n    for (k = 0; k < observedFrequencies.length; k++) {\n        chiSquared += Math.pow(\n            observedFrequencies[k] - expectedFrequencies[k], 2) /\n            expectedFrequencies[k];\n    }\n\n    // Calculate degrees of freedom for this test and look it up in the\n    // `chiSquaredDistributionTable` in order to\n    // accept or reject the goodness-of-fit of the hypothesized distribution.\n    degreesOfFreedom = observedFrequencies.length - c - 1;\n    return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared;\n}\n\nmodule.exports = chiSquaredGoodnessOfFit;\n","'use strict';\n\n/**\n * Split an array into chunks of a specified size. This function\n * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)\n * function, and thus will insert smaller-sized chunks at the end if\n * the input size is not divisible by the chunk size.\n *\n * `sample` is expected to be an array, and `chunkSize` a number.\n * The `sample` array can contain any kind of data.\n *\n * @param {Array} sample any array of values\n * @param {number} chunkSize size of each output array\n * @returns {Array<Array>} a chunked array\n * @example\n * console.log(chunk([1, 2, 3, 4], 2)); // [[1, 2], [3, 4]]\n */\nfunction chunk(sample, chunkSize) {\n\n    // a list of result chunks, as arrays in an array\n    var output = [];\n\n    // `chunkSize` must be zero or higher - otherwise the loop below,\n    // in which we call `start += chunkSize`, will loop infinitely.\n    // So, we'll detect and return null in that case to indicate\n    // invalid input.\n    if (chunkSize <= 0) {\n        return null;\n    }\n\n    // `start` is the index at which `.slice` will start selecting\n    // new array elements\n    for (var start = 0; start < sample.length; start += chunkSize) {\n\n        // for each chunk, slice that part of the array and add it\n        // to the output. The `.slice` function does not change\n        // the original array.\n        output.push(sample.slice(start, start + chunkSize));\n    }\n    return output;\n}\n\nmodule.exports = chunk;\n","'use strict';\n\nvar sortedUniqueCount = require('./sorted_unique_count'),\n    numericSort = require('./numeric_sort');\n\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} columns\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\nfunction makeMatrix(columns, rows) {\n    var matrix = [];\n    for (var i = 0; i < columns; i++) {\n        var column = [];\n        for (var j = 0; j < rows; j++) {\n            column.push(0);\n        }\n        matrix.push(column);\n    }\n    return matrix;\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} data input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(data, nClusters) {\n\n    if (nClusters > data.length) {\n        throw new Error('Cannot generate more classes than there are data values');\n    }\n\n    var sorted = numericSort(data),\n        // we'll use this as the maximum number of clusters\n        uniqueCount = sortedUniqueCount(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n        return [sorted];\n    }\n\n    // named 'D' originally\n    var matrix = makeMatrix(nClusters, sorted.length),\n        // named 'B' originally\n        backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n\n    // The outer loop iterates through clusters, from 0 to nClusters.\n    for (var cluster = 0; cluster < nClusters; cluster++) {\n\n        // At the start of each loop, the mean starts as the first element\n        var firstClusterMean = sorted[0];\n\n        for (var sortedIdx = Math.max(cluster, 1);\n             sortedIdx < sorted.length;\n             sortedIdx++) {\n\n            if (cluster === 0) {\n\n                // Increase the running sum of squares calculation by this\n                // new value\n                var squaredDifference = Math.pow(\n                    sorted[sortedIdx] - firstClusterMean, 2);\n                matrix[cluster][sortedIdx] = matrix[cluster][sortedIdx - 1] +\n                    (sortedIdx / (sortedIdx + 1)) * squaredDifference;\n\n                // We're computing a running mean by taking the previous\n                // mean value, multiplying it by the number of elements\n                // seen so far, and then dividing it by the number of\n                // elements total.\n                var newSum = sortedIdx * firstClusterMean + sorted[sortedIdx];\n                firstClusterMean = newSum / (sortedIdx + 1);\n\n            } else {\n\n                var sumSquaredDistances = 0,\n                    meanXJ = 0;\n\n                for (var j = sortedIdx; j >= cluster; j--) {\n\n                    sumSquaredDistances += (sortedIdx - j) /\n                        (sortedIdx - j + 1) *\n                        Math.pow(sorted[j] - meanXJ, 2);\n\n                    meanXJ = (sorted[j] + (sortedIdx - j) * meanXJ) /\n                        (sortedIdx - j + 1);\n\n                    if (j === sortedIdx) {\n                        matrix[cluster][sortedIdx] = sumSquaredDistances;\n                        backtrackMatrix[cluster][sortedIdx] = j;\n                        if (j > 0) {\n                            matrix[cluster][sortedIdx] += matrix[cluster - 1][j - 1];\n                        }\n                    } else {\n                        if (j === 0) {\n                            if (sumSquaredDistances <= matrix[cluster][sortedIdx]) {\n                                matrix[cluster][sortedIdx] = sumSquaredDistances;\n                                backtrackMatrix[cluster][sortedIdx] = j;\n                            }\n                        } else if (sumSquaredDistances + matrix[cluster - 1][j - 1] < matrix[cluster][sortedIdx]) {\n                            matrix[cluster][sortedIdx] = sumSquaredDistances + matrix[cluster - 1][j - 1];\n                            backtrackMatrix[cluster][sortedIdx] = j;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    var clusters = [],\n        clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\n        var clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n        // fill the cluster from the sorted input by taking a slice of the\n        // array. the backtrack matrix makes this easy - it stores the\n        // indexes where the cluster should start and end.\n        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n        if (cluster > 0) {\n            clusterRight = clusterLeft - 1;\n        }\n    }\n\n    return clusters;\n}\n\nmodule.exports = ckmeans;\n","'use strict';\n\nvar standardNormalTable = require('./standard_normal_table');\n\n/**\n * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**\n *\n * Since probability tables cannot be\n * printed for every normal distribution, as there are an infinite variety\n * of normal distributions, it is common practice to convert a normal to a\n * standard normal and then use the standard normal table to find probabilities.\n *\n * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability\n * instead of looking it up in a table.\n *\n * @param {number} z\n * @returns {number} cumulative standard normal probability\n */\nfunction cumulativeStdNormalProbability(z) {\n\n    // Calculate the position of this value.\n    var absZ = Math.abs(z),\n        // Each row begins with a different\n        // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table\n        // corresponds to a range of 0.01 in the input values, so the value is\n        // multiplied by 100.\n        index = Math.min(Math.round(absZ * 100), standardNormalTable.length - 1);\n\n    // The index we calculate must be in the table as a positive value,\n    // but we still pay attention to whether the input is positive\n    // or negative, and flip the output value as a last step.\n    if (z >= 0) {\n        return standardNormalTable[index];\n    } else {\n        // due to floating-point arithmetic, values in the table with\n        // 4 significant figures can nevertheless end up as repeating\n        // fractions when they're computed here.\n        return +(1 - standardNormalTable[index]).toFixed(4);\n    }\n}\n\nmodule.exports = cumulativeStdNormalProbability;\n","'use strict';\n\n/**\n * We use `ε`, epsilon, as a stopping criterion when we want to iterate\n * until we're \"close enough\". Epsilon is a very small number: for\n * simple statistics, that number is **0.0001**\n *\n * This is used in calculations like the binomialDistribution, in which\n * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):\n * it progresses until it is close enough.\n *\n * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),\n * where we're trying to find a local minimum of a function's derivative,\n * given by the `fDerivative` method.\n *\n * @example\n * // From calculation, we expect that the local minimum occurs at x=9/4\n * var x_old = 0;\n * // The algorithm starts at x=6\n * var x_new = 6;\n * var stepSize = 0.01;\n *\n * function fDerivative(x) {\n *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);\n * }\n *\n * // The loop runs until the difference between the previous\n * // value and the current value is smaller than epsilon - a rough\n * // meaure of 'close enough'\n * while (Math.abs(x_new - x_old) > ss.epsilon) {\n *   x_old = x_new;\n *   x_new = x_old - stepSize * fDerivative(x_old);\n * }\n *\n * console.log('Local minimum occurs at', x_new);\n */\nvar epsilon = 0.0001;\n\nmodule.exports = epsilon;\n","'use strict';\n\n/**\n * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**\n *\n * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a\n * normal distribution with standard deviation sd is within x of the mean.\n *\n * This function returns a numerical approximation to the exact value.\n *\n * @param {number} x input\n * @return {number} error estimation\n * @example\n * errorFunction(1); //= 0.8427\n */\nfunction errorFunction(x) {\n    var t = 1 / (1 + 0.5 * Math.abs(x));\n    var tau = t * Math.exp(-Math.pow(x, 2) -\n        1.26551223 +\n        1.00002368 * t +\n        0.37409196 * Math.pow(t, 2) +\n        0.09678418 * Math.pow(t, 3) -\n        0.18628806 * Math.pow(t, 4) +\n        0.27886807 * Math.pow(t, 5) -\n        1.13520398 * Math.pow(t, 6) +\n        1.48851587 * Math.pow(t, 7) -\n        0.82215223 * Math.pow(t, 8) +\n        0.17087277 * Math.pow(t, 9));\n    if (x >= 0) {\n        return 1 - tau;\n    } else {\n        return tau - 1;\n    }\n}\n\nmodule.exports = errorFunction;\n","'use strict';\n\n/**\n * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive\n * integers less than or equal to n. Often factorial is implemented\n * recursively, but this iterative approach is significantly faster\n * and simpler.\n *\n * @param {number} n input\n * @returns {number} factorial: n!\n * @example\n * console.log(factorial(5)); // 120\n */\nfunction factorial(n) {\n\n    // factorial is mathematically undefined for negative numbers\n    if (n < 0 ) { return null; }\n\n    // typically you'll expand the factorial function going down, like\n    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,\n    // counting from 2 up to the number in question, and since anything\n    // multiplied by 1 is itself, the loop only needs to start at 2.\n    var accumulator = 1;\n    for (var i = 2; i <= n; i++) {\n        // for each number up to and including the number `n`, multiply\n        // the accumulator my that number.\n        accumulator *= i;\n    }\n    return accumulator;\n}\n\nmodule.exports = factorial;\n","'use strict';\n\n/**\n * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is\n * a mean function that is more useful for numbers in different\n * ranges.\n *\n * This is the nth root of the input numbers multiplied by each other.\n *\n * The geometric mean is often useful for\n * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given\n * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple\n * mean will incorrectly estimate an average growth rate, whereas a geometric\n * mean will correctly estimate a growth rate that, over those years,\n * will yield the same end value.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input array\n * @returns {number} geometric mean\n * @example\n * var growthRates = [1.80, 1.166666, 1.428571];\n * var averageGrowth = geometricMean(growthRates);\n * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];\n * var startingValue = 10;\n * var startingValueMean = 10;\n * growthRates.forEach(function(rate) {\n *   startingValue *= rate;\n * });\n * averageGrowthRates.forEach(function(rate) {\n *   startingValueMean *= rate;\n * });\n * startingValueMean === startingValue;\n */\nfunction geometricMean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    // the starting value.\n    var value = 1;\n\n    for (var i = 0; i < x.length; i++) {\n        // the geometric mean is only valid for positive numbers\n        if (x[i] <= 0) { return null; }\n\n        // repeatedly multiply the value by each number\n        value *= x[i];\n    }\n\n    return Math.pow(value, 1 / x.length);\n}\n\nmodule.exports = geometricMean;\n","'use strict';\n\n/**\n * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is\n * a mean function typically used to find the average of rates.\n * This mean is calculated by taking the reciprocal of the arithmetic mean\n * of the reciprocals of the input numbers.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @returns {number} harmonic mean\n * @example\n * ss.harmonicMean([2, 3]) //= 2.4\n */\nfunction harmonicMean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    var reciprocalSum = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        // the harmonic mean is only valid for positive numbers\n        if (x[i] <= 0) { return null; }\n\n        reciprocalSum += 1 / x[i];\n    }\n\n    // divide n by the the reciprocal sum\n    return x.length / reciprocalSum;\n}\n\nmodule.exports = harmonicMean;\n","'use strict';\n\nvar quantile = require('./quantile');\n\n/**\n * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is\n * a measure of statistical dispersion, or how scattered, spread, or\n * concentrated a distribution is. It's computed as the difference between\n * the third quartile and first quartile.\n *\n * @param {Array<number>} sample\n * @returns {number} interquartile range: the span between lower and upper quartile,\n * 0.25 and 0.75\n * @example\n * interquartileRange([0, 1, 2, 3]); //= 2\n */\nfunction interquartileRange(sample) {\n    // We can't derive quantiles from an empty list\n    if (sample.length === 0) { return null; }\n\n    // Interquartile range is the span between the upper quartile,\n    // at `0.75`, and lower quartile, `0.25`\n    return quantile(sample, 0.75) - quantile(sample, 0.25);\n}\n\nmodule.exports = interquartileRange;\n","'use strict';\n\n/**\n * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)\n * returns a numerical approximation to the value that would have caused\n * `errorFunction()` to return x.\n *\n * @param {number} x value of error function\n * @returns {number} estimated inverted value\n */\nfunction inverseErrorFunction(x) {\n    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));\n\n    var inv = Math.sqrt(Math.sqrt(\n        Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -\n        Math.log(1 - x * x) / a) -\n        (2 / (Math.PI * a) + Math.log(1 - x * x) / 2));\n\n    if (x >= 0) {\n        return inv;\n    } else {\n        return -inv;\n    }\n}\n\nmodule.exports = inverseErrorFunction;\n","'use strict';\n\n/**\n * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)\n * is a simple way to find a fitted line\n * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line\n * using the least sum of squares.\n *\n * @param {Array<Array<number>>} data an array of two-element of arrays,\n * like `[[0, 1], [2, 3]]`\n * @returns {Object} object containing slope and intersect of regression line\n * @example\n * linearRegression([[0, 0], [1, 1]]); // { m: 1, b: 0 }\n */\nfunction linearRegression(data) {\n\n    var m, b;\n\n    // Store data length in a local variable to reduce\n    // repeated object property lookups\n    var dataLength = data.length;\n\n    //if there's only one point, arbitrarily choose a slope of 0\n    //and a y-intercept of whatever the y of the initial point is\n    if (dataLength === 1) {\n        m = 0;\n        b = data[0][1];\n    } else {\n        // Initialize our sums and scope the `m` and `b`\n        // variables that define the line.\n        var sumX = 0, sumY = 0,\n            sumXX = 0, sumXY = 0;\n\n        // Use local variables to grab point values\n        // with minimal object property lookups\n        var point, x, y;\n\n        // Gather the sum of all x values, the sum of all\n        // y values, and the sum of x^2 and (x*y) for each\n        // value.\n        //\n        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy\n        for (var i = 0; i < dataLength; i++) {\n            point = data[i];\n            x = point[0];\n            y = point[1];\n\n            sumX += x;\n            sumY += y;\n\n            sumXX += x * x;\n            sumXY += x * y;\n        }\n\n        // `m` is the slope of the regression line\n        m = ((dataLength * sumXY) - (sumX * sumY)) /\n            ((dataLength * sumXX) - (sumX * sumX));\n\n        // `b` is the y-intercept of the line.\n        b = (sumY / dataLength) - ((m * sumX) / dataLength);\n    }\n\n    // Return both values as an object.\n    return {\n        m: m,\n        b: b\n    };\n}\n\n\nmodule.exports = linearRegression;\n","'use strict';\n\n/**\n * Given the output of `linearRegression`: an object\n * with `m` and `b` values indicating slope and intercept,\n * respectively, generate a line function that translates\n * x values into y values.\n *\n * @param {Object} mb object with `m` and `b` members, representing\n * slope and intersect of desired line\n * @returns {Function} method that computes y-value at any given\n * x-value on the line.\n * @example\n * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));\n * l(0) //= 0\n * l(2) //= 2\n */\nfunction linearRegressionLine(mb) {\n    // Return a function that computes a `y` value for each\n    // x value it is given, based on the values of `b` and `a`\n    // that we just computed.\n    return function(x) {\n        return mb.b + (mb.m * x);\n    };\n}\n\nmodule.exports = linearRegressionLine;\n","'use strict';\n\nvar median = require('./median');\n\n/**\n * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is\n * a robust measure of statistical\n * dispersion. It is more resilient to outliers than the standard deviation.\n *\n * @param {Array<number>} x input array\n * @returns {number} median absolute deviation\n * @example\n * mad([1, 1, 2, 2, 4, 6, 9]); //= 1\n */\nfunction mad(x) {\n    // The mad of nothing is null\n    if (!x || x.length === 0) { return null; }\n\n    var medianValue = median(x),\n        medianAbsoluteDeviations = [];\n\n    // Make a list of absolute deviations from the median\n    for (var i = 0; i < x.length; i++) {\n        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));\n    }\n\n    // Find the median value of that list\n    return median(medianAbsoluteDeviations);\n}\n\nmodule.exports = mad;\n","'use strict';\n\n/**\n * This computes the maximum number in an array.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} maximum value\n * @example\n * console.log(max([1, 2, 3, 4])); // 4\n */\nfunction max(x) {\n    var value;\n    for (var i = 0; i < x.length; i++) {\n        // On the first iteration of this loop, max is\n        // undefined and is thus made the maximum element in the array\n        if (x[i] > value || value === undefined) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = max;\n","'use strict';\n\nvar sum = require('./sum');\n\n/**\n * The mean, _also known as average_,\n * is the sum of all values over the number of values.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input values\n * @returns {number} mean\n * @example\n * console.log(mean([0, 10])); // 5\n */\nfunction mean(x) {\n    // The mean of no numbers is null\n    if (x.length === 0) { return null; }\n\n    return sum(x) / x.length;\n}\n\nmodule.exports = mean;\n","'use strict';\n\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [median](http://en.wikipedia.org/wiki/Median) is\n * the middle number of a list. This is often a good indicator of 'the middle'\n * when there are outliers that skew the `mean()` value.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * The median isn't necessarily one of the elements in the list: the value\n * can be the average of two elements if the list has an even length\n * and the two central values are different.\n *\n * @param {Array<number>} x input\n * @returns {number} median value\n * @example\n * var incomes = [10, 2, 5, 100, 2, 1];\n * median(incomes); //= 3.5\n */\nfunction median(x) {\n    // The median of an empty list is null\n    if (x.length === 0) { return null; }\n\n    // Sorting the array makes it easy to find the center, but\n    // use `.slice()` to ensure the original array `x` is not modified\n    var sorted = numericSort(x);\n\n    // If the length of the list is odd, it's the central number\n    if (sorted.length % 2 === 1) {\n        return sorted[(sorted.length - 1) / 2];\n    // Otherwise, the median is the average of the two numbers\n    // at the center of the list\n    } else {\n        var a = sorted[sorted.length / 2 - 1];\n        var b = sorted[sorted.length / 2];\n        return (a + b) / 2;\n    }\n}\n\nmodule.exports = median;\n","'use strict';\n\n/**\n * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} minimum value\n * @example\n * min([1, 5, -10, 100, 2]); // -100\n */\nfunction min(x) {\n    var value;\n    for (var i = 0; i < x.length; i++) {\n        // On the first iteration of this loop, min is\n        // undefined and is thus made the minimum element in the array\n        if (x[i] < value || value === undefined) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = min;\n","'use strict';\n\n/**\n * **Mixin** simple_statistics to a single Array instance if provided\n * or the Array native object if not. This is an optional\n * feature that lets you treat simple_statistics as a native feature\n * of Javascript.\n *\n * @param {Object} ss simple statistics\n * @param {Array} [array=] a single array instance which will be augmented\n * with the extra methods. If omitted, mixin will apply to all arrays\n * by changing the global `Array.prototype`.\n * @returns {*} the extended Array, or Array.prototype if no object\n * is given.\n *\n * @example\n * var myNumbers = [1, 2, 3];\n * mixin(ss, myNumbers);\n * console.log(myNumbers.sum()); // 6\n */\nfunction mixin(ss, array) {\n    var support = !!(Object.defineProperty && Object.defineProperties);\n    // Coverage testing will never test this error.\n    /* istanbul ignore next */\n    if (!support) {\n        throw new Error('without defineProperty, simple-statistics cannot be mixed in');\n    }\n\n    // only methods which work on basic arrays in a single step\n    // are supported\n    var arrayMethods = ['median', 'standardDeviation', 'sum',\n        'sampleSkewness',\n        'mean', 'min', 'max', 'quantile', 'geometricMean',\n        'harmonicMean', 'root_mean_square'];\n\n    // create a closure with a method name so that a reference\n    // like `arrayMethods[i]` doesn't follow the loop increment\n    function wrap(method) {\n        return function() {\n            // cast any arguments into an array, since they're\n            // natively objects\n            var args = Array.prototype.slice.apply(arguments);\n            // make the first argument the array itself\n            args.unshift(this);\n            // return the result of the ss method\n            return ss[method].apply(ss, args);\n        };\n    }\n\n    // select object to extend\n    var extending;\n    if (array) {\n        // create a shallow copy of the array so that our internal\n        // operations do not change it by reference\n        extending = array.slice();\n    } else {\n        extending = Array.prototype;\n    }\n\n    // for each array function, define a function that gets\n    // the array as the first argument.\n    // We use [defineProperty](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty)\n    // because it allows these properties to be non-enumerable:\n    // `for (var in x)` loops will not run into problems with this\n    // implementation.\n    for (var i = 0; i < arrayMethods.length; i++) {\n        Object.defineProperty(extending, arrayMethods[i], {\n            value: wrap(arrayMethods[i]),\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n\n    return extending;\n}\n\nmodule.exports = mixin;\n","'use strict';\n\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @returns {number} mode\n * @example\n * mode([0, 0, 1]); //= 0\n */\nfunction mode(x) {\n\n    // Handle edge cases:\n    // The median of an empty list is null\n    if (x.length === 0) { return null; }\n    else if (x.length === 1) { return x[0]; }\n\n    // Sorting the array lets us iterate through it below and be sure\n    // that every time we see a new number it's new and we'll never\n    // see the same number twice\n    var sorted = numericSort(x);\n\n    // This assumes it is dealing with an array of size > 1, since size\n    // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n    // array.\n    var last = sorted[0],\n        // store the mode as we find new modes\n        value,\n        // store how many times we've seen the mode\n        maxSeen = 0,\n        // how many times the current candidate for the mode\n        // has been seen\n        seenThis = 1;\n\n    // end at sorted.length + 1 to fix the case in which the mode is\n    // the highest number that occurs in the sequence. the last iteration\n    // compares sorted[i], which is undefined, to the highest number\n    // in the series\n    for (var i = 1; i < sorted.length + 1; i++) {\n        // we're seeing a new number pass by\n        if (sorted[i] !== last) {\n            // the last number is the new mode since we saw it more\n            // often than the old one\n            if (seenThis > maxSeen) {\n                maxSeen = seenThis;\n                value = last;\n            }\n            seenThis = 1;\n            last = sorted[i];\n        // if this isn't a new number, it's one more occurrence of\n        // the potential mode\n        } else { seenThis++; }\n    }\n    return value;\n}\n\nmodule.exports = mode;\n","'use strict';\n\n/**\n * Sort an array of numbers by their numeric value, ensuring that the\n * array is not changed in place.\n *\n * This is necessary because the default behavior of .sort\n * in JavaScript is to sort arrays as string values\n *\n *     [1, 10, 12, 102, 20].sort()\n *     // output\n *     [1, 10, 102, 12, 20]\n *\n * @param {Array<number>} array input array\n * @return {Array<number>} sorted array\n * @private\n * @example\n * numericSort([3, 2, 1]) // [1, 2, 3]\n */\nfunction numericSort(array) {\n    return array\n        // ensure the array is changed in-place\n        .slice()\n        // comparator function that treats input as numeric\n        .sort(function(a, b) {\n            return a - b;\n        });\n}\n\nmodule.exports = numericSort;\n","'use strict';\n\n/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nfunction PerceptronModel() {\n    // The weights, or coefficients of the model;\n    // weights are only populated when training with data.\n    this.weights = [];\n    // The bias term, or intercept; it is also a weight but\n    // it's stored separately for convenience as it is always\n    // multiplied by one.\n    this.bias = 0;\n}\n\n/**\n * **Predict**: Use an array of features with the weight array and bias\n * to predict whether an example is labeled 0 or 1.\n *\n * @param {Array<number>} features an array of features as numbers\n * @returns {number} 1 if the score is over 0, otherwise 0\n */\nPerceptronModel.prototype.predict = function(features) {\n\n    // Only predict if previously trained\n    // on the same size feature array(s).\n    if (features.length !== this.weights.length) { return null; }\n\n    // Calculate the sum of features times weights,\n    // with the bias added (implicitly times one).\n    var score = 0;\n    for (var i = 0; i < this.weights.length; i++) {\n        score += this.weights[i] * features[i];\n    }\n    score += this.bias;\n\n    // Classify as 1 if the score is over 0, otherwise 0.\n    if (score > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * **Train** the classifier with a new example, which is\n * a numeric array of features and a 0 or 1 label.\n *\n * @param {Array<number>} features an array of features as numbers\n * @param {number} label either 0 or 1\n * @returns {PerceptronModel} this\n */\nPerceptronModel.prototype.train = function(features, label) {\n    // Require that only labels of 0 or 1 are considered.\n    if (label !== 0 && label !== 1) { return null; }\n    // The length of the feature array determines\n    // the length of the weight array.\n    // The perceptron will continue learning as long as\n    // it keeps seeing feature arrays of the same length.\n    // When it sees a new data shape, it initializes.\n    if (features.length !== this.weights.length) {\n        this.weights = features;\n        this.bias = 1;\n    }\n    // Make a prediction based on current weights.\n    var prediction = this.predict(features);\n    // Update the weights if the prediction is wrong.\n    if (prediction !== label) {\n        var gradient = label - prediction;\n        for (var i = 0; i < this.weights.length; i++) {\n            this.weights[i] += gradient * features[i];\n        }\n        this.bias += gradient;\n    }\n    return this;\n};\n\nmodule.exports = PerceptronModel;\n","'use strict';\n\nvar epsilon = require('./epsilon');\nvar factorial = require('./factorial');\n\n/**\n * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)\n * is a discrete probability distribution that expresses the probability\n * of a given number of events occurring in a fixed interval of time\n * and/or space if these events occur with a known average rate and\n * independently of the time since the last event.\n *\n * The Poisson Distribution is characterized by the strictly positive\n * mean arrival or occurrence rate, `λ`.\n *\n * @param {number} lambda location poisson distribution\n * @returns {number} value of poisson distribution at that point\n */\nfunction poissonDistribution(lambda) {\n    // Check that lambda is strictly positive\n    if (lambda <= 0) { return null; }\n\n    // our current place in the distribution\n    var x = 0,\n        // and we keep track of the current cumulative probability, in\n        // order to know when to stop calculating chances.\n        cumulativeProbability = 0,\n        // the calculated cells to be returned\n        cells = {};\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = (Math.pow(Math.E, -lambda) * Math.pow(lambda, x)) / factorial(x);\n        cumulativeProbability += cells[x];\n        x++;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = poissonDistribution;\n","'use strict';\n\nvar epsilon = require('./epsilon');\nvar inverseErrorFunction = require('./inverse_error_function');\n\n/**\n * The [Probit](http://en.wikipedia.org/wiki/Probit)\n * is the inverse of cumulativeStdNormalProbability(),\n * and is also known as the normal quantile function.\n *\n * It returns the number of standard deviations from the mean\n * where the p'th quantile of values can be found in a normal distribution.\n * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are\n * normally found within 1 standard deviation above or below the mean.\n *\n * @param {number} p\n * @returns {number} probit\n */\nfunction probit(p) {\n    if (p === 0) {\n        p = epsilon;\n    } else if (p >= 1) {\n        p = 1 - epsilon;\n    }\n    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);\n}\n\nmodule.exports = probit;\n","'use strict';\n\nvar quantileSorted = require('./quantile_sorted');\nvar numericSort = require('./numeric_sort');\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} sample a sample from the population\n * @param {number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * var data = [3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20];\n * quantile(data, 1); //= max(data);\n * quantile(data, 0); //= min(data);\n * quantile(data, 0.5); //= 9\n */\nfunction quantile(sample, p) {\n\n    // We can't derive quantiles from an empty list\n    if (sample.length === 0) { return null; }\n\n    // Sort a copy of the array. We'll need a sorted array to index\n    // the values in sorted order.\n    var sorted = numericSort(sample);\n\n    if (p.length) {\n        // Initialize the result array\n        var results = [];\n        // For each requested quantile\n        for (var i = 0; i < p.length; i++) {\n            results[i] = quantileSorted(sorted, p[i]);\n        }\n        return results;\n    } else {\n        return quantileSorted(sorted, p);\n    }\n}\n\nmodule.exports = quantile;\n","'use strict';\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} sample input data\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @example\n * var data = [3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20];\n * quantileSorted(data, 1); //= max(data);\n * quantileSorted(data, 0); //= min(data);\n * quantileSorted(data, 0.5); //= 9\n */\nfunction quantileSorted(sample, p) {\n    var idx = sample.length * p;\n    if (p < 0 || p > 1) {\n        return null;\n    } else if (p === 1) {\n        // If p is 1, directly return the last element\n        return sample[sample.length - 1];\n    } else if (p === 0) {\n        // If p is 0, directly return the first element\n        return sample[0];\n    } else if (idx % 1 !== 0) {\n        // If p is not integer, return the next element in array\n        return sample[Math.ceil(idx) - 1];\n    } else if (sample.length % 2 === 0) {\n        // If the list has even-length, we'll take the average of this number\n        // and the next value, if there is one\n        return (sample[idx - 1] + sample[idx]) / 2;\n    } else {\n        // Finally, in the simple case of an integer value\n        // with an odd-length list, return the sample value at the index.\n        return sample[idx];\n    }\n}\n\nmodule.exports = quantileSorted;\n","'use strict';\n\n/**\n * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)\n * value of data compared with a function `f`\n * is the sum of the squared differences between the prediction\n * and the actual value.\n *\n * @param {Array<Array<number>>} data input data: this should be doubly-nested\n * @param {Function} func function called on `[i][0]` values within the dataset\n * @returns {number} r-squared value\n * @example\n * var samples = [[0, 0], [1, 1]];\n * var regressionLine = linearRegressionLine(linearRegression(samples));\n * rSquared(samples, regressionLine); //= 1 this line is a perfect fit\n */\nfunction rSquared(data, func) {\n    if (data.length < 2) { return 1; }\n\n    // Compute the average y value for the actual\n    // data set in order to compute the\n    // _total sum of squares_\n    var sum = 0, average;\n    for (var i = 0; i < data.length; i++) {\n        sum += data[i][1];\n    }\n    average = sum / data.length;\n\n    // Compute the total sum of squares - the\n    // squared difference between each point\n    // and the average of all points.\n    var sumOfSquares = 0;\n    for (var j = 0; j < data.length; j++) {\n        sumOfSquares += Math.pow(average - data[j][1], 2);\n    }\n\n    // Finally estimate the error: the squared\n    // difference between the estimate and the actual data\n    // value at each point.\n    var err = 0;\n    for (var k = 0; k < data.length; k++) {\n        err += Math.pow(data[k][1] - func(data[k][0]), 2);\n    }\n\n    // As the error grows larger, its ratio to the\n    // sum of squares increases and the r squared\n    // value grows lower.\n    return 1 - err / sumOfSquares;\n}\n\nmodule.exports = rSquared;\n","'use strict';\n\n/**\n * The Root Mean Square (RMS) is\n * a mean function used as a measure of the magnitude of a set\n * of numbers, regardless of their sign.\n * This is the square root of the mean of the squares of the\n * input numbers.\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @returns {number} root mean square\n * @example\n * rootMeanSquare([-1, 1, -1, 1]); //= 1\n */\nfunction rootMeanSquare(x) {\n    if (x.length === 0) { return null; }\n\n    var sumOfSquares = 0;\n    for (var i = 0; i < x.length; i++) {\n        sumOfSquares += Math.pow(x[i], 2);\n    }\n\n    return Math.sqrt(sumOfSquares / x.length);\n}\n\nmodule.exports = rootMeanSquare;\n","'use strict';\n\nvar shuffle = require('./shuffle');\n\n/**\n * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)\n * from a given array of `n` elements.\n *\n * The sampled values will be in any order, not necessarily the order\n * they appear in the input.\n *\n * @param {Array} array input array. can contain any type\n * @param {number} n count of how many elements to take\n * @param {Function} [randomSource=Math.random] an optional source of entropy\n * instead of Math.random\n * @return {Array} subset of n elements in original array\n * @example\n * var values = [1, 2, 4, 5, 6, 7, 8, 9];\n * sample(values, 3); // returns 3 random values, like [2, 5, 8];\n */\nfunction sample(array, n, randomSource) {\n    // shuffle the original array using a fisher-yates shuffle\n    var shuffled = shuffle(array, randomSource);\n\n    // and then return a subset of it - the first `n` elements.\n    return shuffled.slice(0, n);\n}\n\nmodule.exports = sample;\n","'use strict';\n\nvar sampleCovariance = require('./sample_covariance');\nvar sampleStandardDeviation = require('./sample_standard_deviation');\n\n/**\n * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is\n * a measure of how correlated two datasets are, between -1 and 1\n *\n * @param {Array<number>} x first input\n * @param {Array<number>} y second input\n * @returns {number} sample correlation\n * @example\n * var a = [1, 2, 3, 4, 5, 6];\n * var b = [2, 2, 3, 4, 5, 60];\n * sampleCorrelation(a, b); //= 0.691\n */\nfunction sampleCorrelation(x, y) {\n    var cov = sampleCovariance(x, y),\n        xstd = sampleStandardDeviation(x),\n        ystd = sampleStandardDeviation(y);\n\n    if (cov === null || xstd === null || ystd === null) {\n        return null;\n    }\n\n    return cov / xstd / ystd;\n}\n\nmodule.exports = sampleCorrelation;\n","'use strict';\n\nvar mean = require('./mean');\n\n/**\n * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:\n * how much do the two datasets move together?\n * x and y are two datasets, represented as arrays of numbers.\n *\n * @param {Array<number>} x first input\n * @param {Array<number>} y second input\n * @returns {number} sample covariance\n * @example\n * var x = [1, 2, 3, 4, 5, 6];\n * var y = [6, 5, 4, 3, 2, 1];\n * sampleCovariance(x, y); //= -3.5\n */\nfunction sampleCovariance(x, y) {\n\n    // The two datasets must have the same length which must be more than 1\n    if (x.length <= 1 || x.length !== y.length) {\n        return null;\n    }\n\n    // determine the mean of each dataset so that we can judge each\n    // value of the dataset fairly as the difference from the mean. this\n    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance\n    // does not suffer because of the difference in absolute values\n    var xmean = mean(x),\n        ymean = mean(y),\n        sum = 0;\n\n    // for each pair of values, the covariance increases when their\n    // difference from the mean is associated - if both are well above\n    // or if both are well below\n    // the mean, the covariance increases significantly.\n    for (var i = 0; i < x.length; i++) {\n        sum += (x[i] - xmean) * (y[i] - ymean);\n    }\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // the covariance is weighted by the length of the datasets.\n    return sum / besselsCorrection;\n}\n\nmodule.exports = sampleCovariance;\n","'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\nvar sampleStandardDeviation = require('./sample_standard_deviation');\n\n/**\n * [Skewness](http://en.wikipedia.org/wiki/Skewness) is\n * a measure of the extent to which a probability distribution of a\n * real-valued random variable \"leans\" to one side of the mean.\n * The skewness value can be positive or negative, or even undefined.\n *\n * Implementation is based on the adjusted Fisher-Pearson standardized\n * moment coefficient, which is the version found in Excel and several\n * statistical packages including Minitab, SAS and SPSS.\n *\n * @param {Array<number>} x input\n * @returns {number} sample skewness\n * @example\n * var data = [2, 4, 6, 3, 1];\n * sampleSkewness(data); //= 0.5901286564\n */\nfunction sampleSkewness(x) {\n    // The skewness of less than three arguments is null\n    if (x.length < 3) { return null; }\n\n    var n = x.length,\n        cubedS = Math.pow(sampleStandardDeviation(x), 3),\n        sumCubedDeviations = sumNthPowerDeviations(x, 3);\n\n    return n * sumCubedDeviations / ((n - 1) * (n - 2) * cubedS);\n}\n\nmodule.exports = sampleSkewness;\n","'use strict';\n\nvar sampleVariance = require('./sample_variance');\n\n/**\n * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n * is the square root of the variance.\n *\n * @param {Array<number>} x input array\n * @returns {number} sample standard deviation\n * @example\n * ss.sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]);\n * //= 2.138\n */\nfunction sampleStandardDeviation(x) {\n    // The standard deviation of no numbers is null\n    if (x.length <= 1) { return null; }\n\n    return Math.sqrt(sampleVariance(x));\n}\n\nmodule.exports = sampleStandardDeviation;\n","'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\n\n/*\n * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)\n * is the sum of squared deviations from the mean. The sample variance\n * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):\n * instead of dividing the sum of squared deviations by the length of the input,\n * it is divided by the length minus one. This corrects the bias in estimating\n * a value from a set that you don't know if full.\n *\n * References:\n * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)\n *\n * @param {Array<number>} x input array\n * @return {number} sample variance\n * @example\n * sampleVariance([1, 2, 3, 4, 5]); //= 2.5\n */\nfunction sampleVariance(x) {\n    // The variance of no numbers is null\n    if (x.length <= 1) { return null; }\n\n    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // Find the mean value of that list\n    return sumSquaredDeviationsValue / besselsCorrection;\n}\n\nmodule.exports = sampleVariance;\n","'use strict';\n\nvar shuffleInPlace = require('./shuffle_in_place');\n\n/*\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * is a fast way to create a random permutation of a finite set. This is\n * a function around `shuffle_in_place` that adds the guarantee that\n * it will not modify its input.\n *\n * @param {Array} sample an array of any kind of element\n * @param {Function} [randomSource=Math.random] an optional entropy source\n * @return {Array} shuffled version of input\n * @example\n * var shuffled = shuffle([1, 2, 3, 4]);\n * shuffled; // = [2, 3, 1, 4] or any other random permutation\n */\nfunction shuffle(sample, randomSource) {\n    // slice the original array so that it is not modified\n    sample = sample.slice();\n\n    // and then shuffle that shallow-copied array, in place\n    return shuffleInPlace(sample.slice(), randomSource);\n}\n\nmodule.exports = shuffle;\n","'use strict';\n\n/*\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * in-place - which means that it **will change the order of the original\n * array by reference**.\n *\n * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)\n * of a set.\n *\n * @param {Array} sample input array\n * @param {Function} [randomSource=Math.random] an optional source of entropy\n * @returns {Array} sample\n * @example\n * var sample = [1, 2, 3, 4];\n * shuffleInPlace(sample);\n * // sample is shuffled to a value like [2, 1, 4, 3]\n */\nfunction shuffleInPlace(sample, randomSource) {\n\n    // a custom random number source can be provided if you want to use\n    // a fixed seed or another random number generator, like\n    // [random-js](https://www.npmjs.org/package/random-js)\n    randomSource = randomSource || Math.random;\n\n    // store the current length of the sample to determine\n    // when no elements remain to shuffle.\n    var length = sample.length;\n\n    // temporary is used to hold an item when it is being\n    // swapped between indices.\n    var temporary;\n\n    // The index to swap at each stage.\n    var index;\n\n    // While there are still items to shuffle\n    while (length > 0) {\n        // chose a random index within the subset of the array\n        // that is not yet shuffled\n        index = Math.floor(randomSource() * length--);\n\n        // store the value that we'll move temporarily\n        temporary = sample[length];\n\n        // swap the value at `sample[length]` with `sample[index]`\n        sample[length] = sample[index];\n        sample[index] = temporary;\n    }\n\n    return sample;\n}\n\nmodule.exports = shuffleInPlace;\n","'use strict';\n\n/**\n * For a sorted input, counting the number of unique values\n * is possible in constant time and constant memory. This is\n * a simple implementation of the algorithm.\n *\n * Values are compared with `===`, so objects and non-primitive objects\n * are not handled in any special way.\n *\n * @param {Array} input an array of primitive values.\n * @returns {number} count of unique values\n * @example\n * sortedUniqueCount([1, 2, 3]); // 3\n * sortedUniqueCount([1, 1, 1]); // 1\n */\nfunction sortedUniqueCount(input) {\n    var uniqueValueCount = 0,\n        lastSeenValue;\n    for (var i = 0; i < input.length; i++) {\n        if (i === 0 || input[i] !== lastSeenValue) {\n            lastSeenValue = input[i];\n            uniqueValueCount++;\n        }\n    }\n    return uniqueValueCount;\n}\n\nmodule.exports = sortedUniqueCount;\n","'use strict';\n\nvar variance = require('./variance');\n\n/**\n * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n * is the square root of the variance. It's useful for measuring the amount\n * of variation or dispersion in a set of values.\n *\n * Standard deviation is only appropriate for full-population knowledge: for\n * samples of a population, {@link sampleStandardDeviation} is\n * more appropriate.\n *\n * @param {Array<number>} x input\n * @returns {number} standard deviation\n * @example\n * var scores = [2, 4, 4, 4, 5, 5, 7, 9];\n * variance(scores); //= 4\n * standardDeviation(scores); //= 2\n */\nfunction standardDeviation(x) {\n    // The standard deviation of no numbers is null\n    if (x.length === 0) { return null; }\n\n    return Math.sqrt(variance(x));\n}\n\nmodule.exports = standardDeviation;\n","'use strict';\n\nvar SQRT_2PI = Math.sqrt(2 * Math.PI);\n\nfunction cumulativeDistribution(z) {\n    var sum = z,\n        tmp = z;\n\n    // 15 iterations are enough for 4-digit precision\n    for (var i = 1; i < 15; i++) {\n        tmp *= z * z / (2 * i + 1);\n        sum += tmp;\n    }\n    return Math.round((0.5 + (sum / SQRT_2PI) * Math.exp(-z * z / 2)) * 1e4) / 1e4;\n}\n\n/**\n * A standard normal table, also called the unit normal table or Z table,\n * is a mathematical table for the values of Φ (phi), which are the values of\n * the cumulative distribution function of the normal distribution.\n * It is used to find the probability that a statistic is observed below,\n * above, or between values on the standard normal distribution, and by\n * extension, any normal distribution.\n *\n * The probabilities are calculated using the\n * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).\n * The table used is the cumulative, and not cumulative from 0 to mean\n * (even though the latter has 5 digits precision, instead of 4).\n */\nvar standardNormalTable = [];\n\nfor (var z = 0; z <= 3.09; z += 0.01) {\n    standardNormalTable.push(cumulativeDistribution(z));\n}\n\nmodule.exports = standardNormalTable;\n","'use strict';\n\n/**\n * The [sum](https://en.wikipedia.org/wiki/Summation) of an array\n * is the result of adding all numbers together, starting from zero.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * console.log(sum([1, 2, 3])); // 6\n */\nfunction sum(x) {\n    var value = 0;\n    for (var i = 0; i < x.length; i++) {\n        value += x[i];\n    }\n    return value;\n}\n\nmodule.exports = sum;\n","'use strict';\n\nvar mean = require('./mean');\n\n/**\n * The sum of deviations to the Nth power.\n * When n=2 it's the sum of squared deviations.\n * When n=3 it's the sum of cubed deviations.\n *\n * @param {Array<number>} x\n * @param {number} n power\n * @returns {number} sum of nth power deviations\n * @example\n * var input = [1, 2, 3];\n * // since the variance of a set is the mean squared\n * // deviations, we can calculate that with sumNthPowerDeviations:\n * var variance = sumNthPowerDeviations(input) / input.length;\n */\nfunction sumNthPowerDeviations(x, n) {\n    var meanValue = mean(x),\n        sum = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        sum += Math.pow(x[i] - meanValue, n);\n    }\n\n    return sum;\n}\n\nmodule.exports = sumNthPowerDeviations;\n","'use strict';\n\nvar standardDeviation = require('./standard_deviation');\nvar mean = require('./mean');\n\n/**\n * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean\n * of a sample to a known value, x.\n *\n * in this case, we're trying to determine whether the\n * population mean is equal to the value that we know, which is `x`\n * here. usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * @param {Array<number>} sample an array of numbers as input\n * @param {number} x expected vale of the population mean\n * @returns {number} value\n * @example\n * tTest([1, 2, 3, 4, 5, 6], 3.385); //= 0.16494154\n */\nfunction tTest(sample, x) {\n    // The mean of the sample\n    var sampleMean = mean(sample);\n\n    // The standard deviation of the sample\n    var sd = standardDeviation(sample);\n\n    // Square root the length of the sample\n    var rootN = Math.sqrt(sample.length);\n\n    // Compute the known value against the sample,\n    // returning the t value\n    return (sampleMean - x) / (sd / rootN);\n}\n\nmodule.exports = tTest;\n","'use strict';\n\nvar mean = require('./mean');\nvar sampleVariance = require('./sample_variance');\n\n/**\n * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).\n * Tests whether \"mean(X)-mean(Y) = difference\", (\n * in the most common case, we often have `difference == 0` to test if two samples\n * are likely to be taken from populations with the same mean value) with\n * no prior knowledge on standard deviations of both samples\n * other than the fact that they have the same standard deviation.\n *\n * Usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * `diff` can be omitted if it equals 0.\n *\n * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)\n * a null hypothesis that the two populations that have been sampled into\n * `sampleX` and `sampleY` are equal to each other.\n *\n * @param {Array<number>} sampleX a sample as an array of numbers\n * @param {Array<number>} sampleY a sample as an array of numbers\n * @param {number} [difference=0]\n * @returns {number} test result\n * @example\n * ss.tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); //= -2.1908902300206643\n */\nfunction tTestTwoSample(sampleX, sampleY, difference) {\n    var n = sampleX.length,\n        m = sampleY.length;\n\n    // If either sample doesn't actually have any values, we can't\n    // compute this at all, so we return `null`.\n    if (!n || !m) { return null; }\n\n    // default difference (mu) is zero\n    if (!difference) {\n        difference = 0;\n    }\n\n    var meanX = mean(sampleX),\n        meanY = mean(sampleY);\n\n    var weightedVariance = ((n - 1) * sampleVariance(sampleX) +\n        (m - 1) * sampleVariance(sampleY)) / (n + m - 2);\n\n    return (meanX - meanY - difference) /\n        Math.sqrt(weightedVariance * (1 / n + 1 / m));\n}\n\nmodule.exports = tTestTwoSample;\n","'use strict';\n\nvar sumNthPowerDeviations = require('./sum_nth_power_deviations');\n\n/**\n * The [variance](http://en.wikipedia.org/wiki/Variance)\n * is the sum of squared deviations from the mean.\n *\n * This is an implementation of variance, not sample variance:\n * see the `sampleVariance` method if you want a sample measure.\n *\n * @param {Array<number>} x a population\n * @returns {number} variance: a value greater than or equal to zero.\n * zero indicates that all values are identical.\n * @example\n * ss.variance([1, 2, 3, 4, 5, 6]); //= 2.917\n */\nfunction variance(x) {\n    // The variance of no numbers is null\n    if (x.length === 0) { return null; }\n\n    // Find the mean of squared deviations between the\n    // mean value and each value.\n    return sumNthPowerDeviations(x, 2) / x.length;\n}\n\nmodule.exports = variance;\n","'use strict';\n\n/**\n * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).\n *\n * The standard score is the number of standard deviations an observation\n * or datum is above or below the mean. Thus, a positive standard score\n * represents a datum above the mean, while a negative standard score\n * represents a datum below the mean. It is a dimensionless quantity\n * obtained by subtracting the population mean from an individual raw\n * score and then dividing the difference by the population standard\n * deviation.\n *\n * The z-score is only defined if one knows the population parameters;\n * if one only has a sample set, then the analogous computation with\n * sample mean and sample standard deviation yields the\n * Student's t-statistic.\n *\n * @param {number} x\n * @param {number} mean\n * @param {number} standardDeviation\n * @return {number} z score\n * @example\n * ss.zScore(78, 80, 5); //= -0.4\n */\nfunction zScore(x, mean, standardDeviation) {\n    return (x - mean) / standardDeviation;\n}\n\nmodule.exports = zScore;\n","/* global d3 */\n\n/**\n * A reusable d3 parallel coordinates generator with statistical coloring\n * @name parallelCoordinates\n * @module parallel coordinates\n * @author Taylor Denouden\n * @param {string} parent | {DOM element} parent - A dom element to append the vis to\n * @return {object} parallelCoordinates\n */\nmodule.exports = function parallelCoordinates(parent) {\n  const _y = {};\n  const _dragging = {};\n  const _line = d3.svg.line();\n  const _axis = d3.svg.axis().orient('left');\n  const _color = d3.scale.linear()\n      .domain([-2, -0.5, 0.5, 2])\n      .range(['#f46d43', '#74add1', '#74add1', '#66bd63'])\n      .interpolate(d3.interpolateLab);\n  let _width;\n  let _height;\n  let _margin;\n  let _svg;\n  let _x;\n  let _background;\n  let _foreground;\n  let _dimensions;\n  let _data;\n  let _lineData;\n\n  /**\n   * Get the x axis position for some dimension and initialize dragging\n   * @private\n   * @param {string} d - The dimension name\n   * @return {float} - The distance to the right of the origin\n   */\n  function position(d) {\n    const v = _dragging[d];\n    return v ? v : _x(d);\n  }\n\n  /**\n   * Generate the line path for a datum.\n   * @private\n   * @param {object} d - An object with axis attributes\n   * @return {string} - SVG path text\n   */\n  function path(d) {\n    return _line(_dimensions.map(p => [position(p), _y[p](d[p])]));\n  }\n\n  /**\n   * Map a list of objects where each object is an attribute with line values to\n   *     a list of objects where each object is a line with its attributes listed\n   * @private\n   * @param {list} data - A list of objects\n   *      eg {\n   *        name: Area,\n   *        data: [14234, 34132],\n   *        scale : d3.scale.linear()\n   *      }\n   *\n   * @return {list} - A list of line objects\n   *      eg {\n   *        Area: 14234\n   *        Bird species: 67\n   *        Distance to Mainland: 14165.85749\n   *        Land within 500m: 2.60546\n   *      }\n   */\n  function dataToLines(data) {\n    const result = [];\n    data[0].data.forEach((d, i) => result[i] = {});\n    data.forEach(function forEachDim(dim) {\n      result.forEach(function addDimData(line, i) {\n        result[i][dim.name] = dim.data[i];\n      });\n    });\n    return result;\n  }\n\n  /**\n   * color by zScore\n   * @private\n   * @param {list} col - A list of values to generate a z-score function from\n   * @return {object} - Function that returns z-score relative to values in col\n   */\n  function zScore(col) {\n    const mean = d3.mean(col);\n    const sigma = d3.deviation(col);\n    // Return zScore if std_dev is not 0, else 0\n    return d => (sigma ? (d - mean) / sigma : 0);\n  }\n\n  /**\n   * Change foreground line color\n   * @private\n   * @param {string} dimension - The name of the dimension to change\n   * @returns {void}\n   */\n  function changeColor(dimension) {\n    _svg.selectAll('.dimension')\n        .style('font-weight', 'normal')\n        .classed('z-scored', false)\n      .filter(d => d === dimension)\n        .style('font-weight', 'bold')\n        .classed('z-scored', true);\n    const z = zScore(_lineData.map(i => parseFloat(i[dimension])));\n\n    // lines\n    _svg.select('.foreground').selectAll('path')\n        .style('stroke', d => _color(z(d[dimension])));\n  }\n\n  /**\n   * Provide a consisten transition length\n   * @private\n   * @param {object} g - An d3 selection that can be transitioned\n   * @return {object} - A d3 transition object\n   */\n  function transition(g) {\n    return g.transition().duration(500);\n  }\n\n  /**\n   * A brushstart callback control\n   * @private\n   * @returns {void}\n   */\n  function brushstart() {\n    d3.event.sourceEvent.stopPropagation();\n  }\n\n  /**\n   * Handles a brush event, toggling the display of foreground lines.\n   * @private\n   * @returns {void}\n   */\n  function brush() {\n    const actives = _dimensions.filter(p => !_y[p].brush.empty());\n    const extents = actives.map(p => _y[p].brush.extent());\n    _foreground.style('display', function toggleDisplay(d) {\n      return actives.every(function brushed(p, i) {\n        const x = Math.round(d[p] * 100) / 100;\n        return Math.round(extents[i][0] * 100) / 100 <= x &&\n                x <= Math.round(extents[i][1] * 100) / 100;\n      }) ? null : 'none';\n    });\n  }\n\n  /**\n   * Generate the chart using private variables on call to chart.render()\n   * @private\n   * @returns {parallelCoordinates}\n   */\n  function _chart() {\n    _svg = d3.select(parent).append('svg')\n        .attr('width', _width + _margin.left + _margin.right)\n        .attr('height', _height + _margin.top + _margin.bottom)\n      .append('g')\n        .attr('transform', 'translate(' + _margin.left + ',' + _margin.top + ')');\n\n    // Create a scale for each dimension\n    _data.forEach(function initScale(d) {\n      _y[d.name] = (d.scale || d3.scale.linear())\n          .domain(d3.extent(d.data))\n          .range([_height, 0]);\n    });\n\n    // Extract the list of _dimensions\n    _dimensions = _data.map(d => d.name);\n    _x = d3.scale.ordinal()\n        .domain(_dimensions)\n        .rangePoints([0, _width], 1);\n\n    // Add grey background lines for context.\n    _background = _svg.append('g')\n        .attr('class', 'background')\n      .selectAll('path')\n        .data(_lineData)\n      .enter().append('path')\n        .attr('d', path);\n\n    // Add blue foreground lines for focus.\n    _foreground = _svg.append('g')\n        .attr('class', 'foreground')\n      .selectAll('path')\n        .data(_lineData)\n      .enter().append('path')\n        .attr('d', path);\n\n    // Add a group element for each dimension.\n    const g = _svg.selectAll('.dimension')\n        .data(_dimensions)\n      .enter().append('g')\n        .attr('class', 'dimension')\n        .attr('transform', d => 'translate(' + _x(d) + ')')\n        .call(d3.behavior.drag()\n          .origin(d => ({ x: _x(d) }))\n          .on('dragstart', function onDragStart(d) {\n            _dragging[d] = _x(d);\n            _background.attr('visibility', 'hidden');\n          })\n          .on('drag', function onDrag(d) {\n            _dragging[d] = Math.min(_width, Math.max(0, d3.event.x));\n            _foreground.attr('d', path);\n            _dimensions.sort((a, b) => position(a) - position(b));\n            _x.domain(_dimensions);\n            g.attr('transform', b => 'translate(' + position(b) + ')');\n          })\n          .on('dragend', function onDragEnd(d) {\n            delete _dragging[d];\n            transition(d3.select(this)).attr('transform',\n                                             'translate(' + _x(d) + ')');\n            transition(_foreground).attr('d', path);\n            _background\n                .attr('d', path)\n              .transition()\n                .delay(500)\n                .duration(0)\n                .attr('visibility', null);\n          }));\n\n    // Add an axis and title.\n    g.append('g')\n        .attr('class', 'axis')\n        .each(function callAxis(d) { d3.select(this).call(_axis.scale(_y[d])); })\n        .on('click', changeColor)\n      .append('text')\n        .style('text-anchor', 'middle')\n        .attr('y', -9)\n        .text(d => d);\n\n    // Add and store a brush for each axis.\n    g.append('g')\n        .attr('class', 'brush')\n        .each(function storeBrush(d) {\n          d3.select(this).call(\n            _y[d].brush = d3.svg.brush()\n                .y(_y[d])\n                .on('brushstart', brushstart)\n                .on('brush', brush)\n          );\n        })\n      .selectAll('rect')\n        .attr('x', -8)\n        .attr('width', 16);\n\n    // Color _dimensions by z-score\n    changeColor(_dimensions[0]);\n  }\n\n  /**\n   * @name render\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.render = function render() {\n    this.call();\n    return _chart;\n  };\n\n  /**\n   * @name redraw\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.redraw = function redraw() {\n    //  Fade out and remove lines\n    transition(_background)\n        .style('opacity', 0)\n      .transition()\n        .remove();\n    transition(_foreground)\n        .style('opacity', 0)\n      .transition()\n        .remove();\n\n    // Adjust axes domains\n    _data.forEach(function adjustAxisDomain(d) {\n      const extent = d3.extent(d.data);\n      if (extent[0] === extent[1]) {\n        extent[0] -= extent[0] / 2;\n        extent[1] += extent[1] / 2;\n      }\n      _y[d.name].domain(extent);\n    });\n\n    // Transition axes\n    _svg.selectAll('.axis')\n        .each(function transitionAxis(d) {\n          transition(d3.select(this)).delay(500).call(_axis.scale(_y[d]));\n        });\n\n    // Rebind data\n    _background = _svg.select('.background')\n        .selectAll('path')\n        .data(_lineData);\n    _foreground = _svg.select('.foreground')\n        .selectAll('path')\n        .data(_lineData);\n    // Update\n    _background\n        .style('opacity', 0)\n        .attr('d', path);\n    _foreground\n        .style('opacity', 0)\n        .attr('d', path);\n\n    // Enter\n    _background.enter().append('path')\n        .style('opacity', 0)\n        .attr('d', path);\n    _foreground.enter().append('path')\n        .style('opacity', 0)\n        .attr('d', path);\n\n    // Update color\n    changeColor(d3.select('.z-scored').data()[0]);\n\n    // Fade in lines\n    transition(_background).delay(1000)\n        .style('opacity', 0.5);\n    transition(_foreground).delay(1000)\n        .style('opacity', 0.5);\n\n    return _chart;\n  };\n\n  /**\n   * @name width\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.width = function width(val) {\n    if (!arguments.length) { return _width; }\n    _width = val;\n    return _chart;\n  };\n\n  /**\n   * @name height\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.height = function height(val) {\n    if (!arguments.length) { return _height; }\n    _height = val;\n    return _chart;\n  };\n\n  /**\n   * @name margin\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.margin = function margin(val) {\n    if (!arguments.length) { return _margin; }\n    _margin = val;\n    return _chart;\n  };\n\n  /**\n   * @name width\n   * @instance\n   * @method\n   * @param {int} val\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.data = function data(val) {\n    if (!arguments.length) { return _data; }\n    _data = val;\n    _lineData = dataToLines(_data);\n    return _chart;\n  };\n\n  return _chart;\n};\n","/* global d3 */\n\n// Include and bundle simple statistics\nconst ss = require('simple-statistics');\n\n/**\n * A reusable d3 scatterplot generator\n * @name scatterplot\n * @module scatterplot\n * @author Taylor Denouden\n * @param {string} parent | {DOM element} parent - A dom element to append the vis to\n * @return {object} scatterplot chart\n */\nmodule.exports = function scatterplot(parent) {\n  let _width;\n  let _height;\n  let _margin;\n  let _data;\n  let _x = d3.scale.linear();\n  let _y = d3.scale.linear();\n  let _xLog = false;\n  let _yLog = false;\n  let _xAxis;\n  let _yAxis;\n  let _xAccessor;\n  let _yAccessor;\n  let _xLabel;\n  let _yLabel;\n  let _color = d3.scale.category10();\n  let _colorAccessor = () => 0;\n  let _keyAccessor = d => d.key;\n  let _radius = 5;\n  let _regLine;\n  let _rSquared = 1;\n  let _correlation = 1;\n  let _covariance = 1;\n  let _svg;\n\n  /**\n   * Return the base ten log of a Number\n   * @private\n   * @param {number} d - A number to apply the operation on\n   * @return {number} log base 10 of d\n   */\n  function log10(d) {\n    return Math.log(d) / Math.log(10);\n  }\n\n  /**\n   * Given an x value of un-transformed data (no log transform etc.),\n   * get the untransformed y coordinate from the regression line\n   * @private\n   * @param {number} x - The untransformed x value in linear space\n   * @param {function} regLine - The regression line calculated using\n   *    a transformed dataset that accounted for the log scales\n   * @return {number} y - The untransformed y value in linear space to plot on the chart\n   */\n  function getY(x, regLine) {\n    const y = regLine(_xLog ? log10(x) : x);\n    return _yLog ? Math.pow(10, y) : y;\n  }\n\n  /**\n   * Calculate all chart statistical values and regresslion linearRegression\n   * @private\n   * @param {Object[]} data - The dataset used to calculate the statistics\n   * @return {Object} stats - An object with all calculated statistics\n   */\n  function calculateStats(data) {\n    // Get regression line formula\n    const ssData = data.map(function ssData(d) {\n      const xD = _xLog ? log10(_xAccessor(d)) : _xAccessor(d);\n      const yD = _yLog ? log10(_yAccessor(d)) : _yAccessor(d);\n      return [xD, yD];\n    });\n    const mb = ss.linearRegression(ssData);\n    const regLine = ss.linearRegressionLine(mb);\n\n    // Calculated statistics\n    const rSquared = ss.rSquared(ssData, regLine);\n    const correlation = ss.sampleCorrelation(\n      ssData.map(d => d[0]),\n      ssData.map(d => d[1])\n    );\n    const covariance = ss.sampleCovariance(\n      ssData.map(d => d[0]),\n      ssData.map(d => d[1])\n    );\n\n    return {\n      reg: mb,\n      regLine,\n      rSquared,\n      correlation,\n      covariance,\n    };\n  }\n\n  /**\n   * Generate the chart using private variables on call to chart.render()\n   * @private\n   * @returns {scatterplot}\n   */\n  function _chart() {\n    // Create svg object\n    _svg = d3.select(parent).append('svg')\n      .attr('width', _width + _margin.left + _margin.right)\n      .attr('height', _height + _margin.top + _margin.bottom)\n    .append('g')\n      .attr('transform', 'translate(' + _margin.left + ',' + _margin.top + ')');\n\n    // Create cleaned dataset that doesn't include non numeric or log(0) values\n    const cleanData = _data\n        .filter(d => !(isNaN(_xAccessor(d)) || isNaN(_yAccessor(d))))\n        .filter(d => !((_xLog && _xAccessor(d) === 0) || (_yLog && _yAccessor(d) === 0)));\n\n    // Set x and y axis based on selected attributes\n    _x.domain(d3.extent(cleanData, _xAccessor))\n      .range([0, _width]);\n    _y.domain(d3.extent(cleanData, _yAccessor))\n      .range([_height, 0]);\n\n    // Create svg axis generators\n    _xAxis = d3.svg.axis()\n      .scale(_x)\n      .orient('bottom')\n      .tickSize(-_height);\n    _yAxis = d3.svg.axis()\n      .scale(_y)\n      .orient('left')\n      .tickSize(-_width);\n\n    // Add axes to chart\n    _svg.append('g')\n        .attr('class', 'x axis')\n        .attr('transform', 'translate(0, ' + _height + ')')\n        .call(_xAxis);\n    _svg.append('g')\n        .attr('class', 'y axis')\n        .call(_yAxis);\n\n    // Add axis labels\n    _svg.append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'end')\n        .attr('x', _width - 10)\n        .attr('y', _height - 5)\n        .text(_xLabel);\n    _svg.append('text')\n        .attr('class', 'y label')\n        .attr('transform', 'rotate(-90)')\n        .attr('text-anchor', 'end')\n        .attr('x', -5)\n        .attr('y', 10)\n        .text(_yLabel);\n\n    // Add frame around chart\n    _svg.append('rect')\n        .attr('class', 'frame')\n        .attr('width', _width)\n        .attr('height', _height);\n\n    // Create clip path\n    _svg.append('defs')\n      .append('clipPath')\n        .attr('id', 'chartClip')\n      .append('rect')\n        .attr('width', _width)\n        .attr('height', _height);\n\n    // Calculate statistics and regression line\n    const stats = calculateStats(cleanData);\n    _regLine = stats.regLine;\n    _rSquared = stats.rSquared;\n    _correlation = stats.correlation;\n    _covariance = stats.covariance;\n\n    // Add regression line to Chart\n    _svg.append('g')\n        .attr('class', 'regression')\n        .attr('clip-path', 'url(#chartClip)')\n      .append('line')\n        .style('stroke', 'black')\n        .style('stroke-width', '1')\n        .style('stroke-dasharray', '5,5,10,5')\n        .attr('x1', _x(_x.domain()[0]))\n        .attr('y1', _y(getY(_x.domain()[0], _regLine)))\n        .attr('x2', _x(_x.domain()[1]))\n        .attr('y2', _y(getY(_x.domain()[1], _regLine)));\n\n    // Add data marks to chart\n    const marks = _svg.selectAll('g.mark')\n        .data(cleanData)\n      .enter().append('g')\n        .attr('class', 'mark');\n\n    marks.append('circle')\n        .attr('cx', d => _x(_xAccessor(d)))\n        .attr('cy', d => _y(_yAccessor(d)))\n        .attr('r', _radius)\n        .attr('fill', d => _color(_colorAccessor(d)));\n\n    marks.append('text')\n        .text(_keyAccessor)\n        .attr('x', d => _x(_xAccessor(d)))\n        .attr('y', d => _y(_yAccessor(d)))\n        .attr('text-anchor', 'end')\n        .attr('dy', -5)\n        .attr('dx', -2);\n  }\n\n  /**\n   * Draw the chart after parameters have been set.\n   * @name render\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.render = function render() {\n    this.call();\n    return _chart;\n  };\n\n  /**\n   * Redraw and transform the chart after parameter changes.\n   * @name redraw\n   * @instance\n   * @method\n   * @return {scatterplot}\n   */\n  _chart.redraw = function redraw() {\n    // Create cleaned dataset that doesn't include non numeric or log(0) values\n    const cleanData = _data\n        .filter(d => !(isNaN(_xAccessor(d)) || isNaN(_yAccessor(d))))\n        .filter(d => !((_xLog && _xAccessor(d) === 0) || (_yLog && _yAccessor(d) === 0)));\n\n    // Update x and y domain\n    _x.domain(d3.extent(cleanData, _xAccessor))\n      .range([0, _width]);\n    _y.domain(d3.extent(cleanData, _yAccessor))\n      .range([_height, 0]);\n\n    // Update axes generator scale\n    _xAxis.scale(_x);\n    _yAxis.scale(_y);\n\n    // Define consistent transition duration\n    const t = 1500;\n\n    // Update axes\n    _svg.select('.x.axis')\n        .transition().duration(t)\n        .call(_xAxis);\n    _svg.select('.y.axis')\n        .transition().duration(t)\n        .call(_yAxis);\n\n    // Update axis labels\n    _svg.select('.x.label')\n        .text(_xLabel);\n    _svg.select('.y.label')\n        .text(_yLabel);\n\n    // Calculate statistics and regression line\n    const stats = calculateStats(cleanData);\n    _regLine = stats.regLine;\n    _rSquared = stats.rSquared;\n    _correlation = stats.correlation;\n    _covariance = stats.covariance;\n\n    // Add regression line to Chart\n    _svg.select('.regression line')\n      .transition().duration(t)\n        .attr('x1', _x(_x.domain()[0]))\n        .attr('y1', _y(getY(_x.domain()[0], _regLine)))\n        .attr('x2', _x(_x.domain()[1]))\n        .attr('y2', _y(getY(_x.domain()[1], _regLine)));\n\n    // Update data and mark positions\n    const marks = _svg.selectAll('g.mark')\n        .data(cleanData, _keyAccessor);\n\n    // Update\n    marks.selectAll('circle')\n      .transition().duration(t)\n        .attr('cx', d => _x(_xAccessor(d)))\n        .attr('cy', d => _y(_yAccessor(d)))\n        .attr('r', _radius)\n        .attr('fill', d => _color(_colorAccessor(d)));\n\n    marks.selectAll('text')\n      .transition().duration(t)\n        .attr('x', d => _x(_xAccessor(d)))\n        .attr('y', d => _y(_yAccessor(d)));\n\n    // Enter\n    const g = marks.enter().append('g')\n        .attr('class', 'mark');\n\n    g.append('circle')\n        .attr('cx', d => _x(_xAccessor(d)))\n        .attr('cy', d => _y(_yAccessor(d)))\n        .attr('r', _radius)\n        .attr('fill', d => _color(_colorAccessor(d)));\n\n    g.append('text')\n        .text(_keyAccessor)\n        .attr('x', d => _x(_xAccessor(d)))\n        .attr('y', d => _y(_yAccessor(d)))\n        .attr('text-anchor', 'end')\n        .attr('dy', -5)\n        .attr('dx', -2);\n\n    // Exit\n    marks.exit().remove();\n\n    return _chart;\n  };\n\n  /**\n   * Set or get the width attribute of a chart.\n   * @name width\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.width = function width(val) {\n    if (!arguments.length) { return _width; }\n    _width = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the height attribute of a chart.\n   * @name height\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.height = function height(val) {\n    if (!arguments.length) { return _height; }\n    _height = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the margin attribute of a chart.\n   * @name margin\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.margin = function margin(val) {\n    if (!arguments.length) { return _margin; }\n    _margin = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the data that accessor functions refer to.\n   * @name data\n   * @instance\n   * @param {int} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.data = function data(val) {\n    if (!arguments.length) { return _data; }\n    _data = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data shown on the x axis.\n   * @name xAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xAccessor = function xAccessor(val) {\n    if (!arguments.length) { return _xAccessor; }\n    _xAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data shown on the y axis.\n   * @name yAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yAccessor = function yAccessor(val) {\n    if (!arguments.length) { return _yAccessor; }\n    _yAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the x axis label.\n   * @name xLabel\n   * @instance\n   * @param {String} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xLabel = function xLabel(val) {\n    if (!arguments.length) { return _xLabel; }\n    _xLabel = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get the y axis label.\n   * @name yLabel\n   * @instance\n   * @param {String} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yLabel = function yLabel(val) {\n    if (!arguments.length) { return _yLabel; }\n    _yLabel = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get whether the x axis scale should be log transformed.\n   * @name xLog\n   * @instance\n   * @param {Boolean} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.xLog = function xLog(val) {\n    if (!arguments.length) { return _xLog; }\n    _xLog = val;\n    _x = _xLog ? d3.scale.log() : d3.scale.linear();\n    return _chart;\n  };\n\n  /**\n   * Set or get whether the y axis scale should be log transformed.\n   * @name yLog\n   * @instance\n   * @param {Boolean} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.yLog = function yLog(val) {\n    if (!arguments.length) { return _yLog; }\n    _yLog = val;\n    _y = _yLog ? d3.scale.log() : d3.scale.linear();\n    return _chart;\n  };\n\n  /**\n   * Set or get a scale function that accepts a data value and returns a color.\n   * @name color\n   * @instance\n   * @param {Function} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.color = function color(val) {\n    if (!arguments.length) { return _color; }\n    _color = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to access the data and pass the value to the color function.\n   * @name colorAccessor\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.colorAccessor = function colorAccessor(val) {\n    if (!arguments.length) { return _colorAccessor; }\n    _colorAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a function used to determine which points shown are the same datum.\n   * Allows for mark translation on redraw.\n   * @name keyAccessor\n   * @instance\n   * @param {Function} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.keyAccessor = function keyAccessor(val) {\n    if (!arguments.length) { return _keyAccessor; }\n    _keyAccessor = val;\n    return _chart;\n  };\n\n  /**\n   * Set or get a radius value or a scale function that accepts a\n   * data value and returns a radius size.\n   * @name radius\n   * @instance\n   * @param {Function|Number} [val]\n   * @return {int}\n   * @return {scatterplot}\n   */\n  _chart.radius = function radius(val) {\n    if (!arguments.length) { return _radius; }\n    _radius = val;\n    return _chart;\n  };\n\n  /**\n   * Return the R squared value determined by the linear regression function.\n   * @name rSquare\n   * @instance\n   * @return {float}\n   */\n  _chart.rSquared = function rSquared() {\n    return _rSquared;\n  };\n\n  /**\n   * Return the correlation value determined by the linear regression function.\n   * @name correlation\n   * @instance\n   * @return {float}\n   */\n  _chart.correlation = function correlation() {\n    return _correlation;\n  };\n\n  /**\n   * Return the covariance value determined by the linear regression function.\n   * @name covariance\n   * @instance\n   * @return {float}\n   */\n  _chart.covariance = function covariance() {\n    return _covariance;\n  };\n\n  return _chart;\n};\n"],"sourceRoot":"/source/"}